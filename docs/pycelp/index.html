<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pycelp API documentation</title>
<meta name="description" content="About the code …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pycelp</code></h1>
</header>
<section id="section-intro">
<h2 id="about-the-code">About the code</h2>
<p><a href="https://github.com/tschad/pycelp"><img alt="github" src="https://img.shields.io/badge/GitHub-tschad%2FpyCELP-blue.svg?style=flat"></a>
<a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract"><img alt="ADS" src="https://img.shields.io/badge/NASA%20ADS-SoPh%2C%20V295%2C%207%2C%2098-red"></a></p>
<p>pyCELP (aka "pi-KELP"): a <strong>py</strong>thon package for <strong>C</strong>oronal <strong>E</strong>mission <strong>L</strong>ine <strong>P</strong>olarization calculations.</p>
<p>Lead Developer: Tom Schad - National Solar Observatory</p>
<p>Code reference documentation available at <a href="https://tschad.github.io/pycelp/pycelp/">tschad.github.io/pycelp</a></p>
<p>**DISCLAIMER: pycelp is still in the early stages of development. Contributors are welcome. **</p>
<h2 id="introduction">Introduction</h2>
<p>pyCELP is used to forward synthesize the polarized emission of ionized atoms formed in the solar corona.
It calculates the atomic density matrix elements for a single ion under coronal equilibrium conditions and excited by a prescribed radiation field and thermal collisions.
In its initial release, pyCELP solves a set of statistical equilibrium equations in the spherical statistical tensor respresentation for a multi-level atom for the no-coherence case.
This approximation is useful in the case of forbidden line emission by visible and infrared lines, such as Fe XIII 1074.7 nm and Si X 3.9 um.
See
<a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract">Schad &amp; Dima 2020</a> for more details and specific references.</p>
<p>A read-only Enhanced PDF version of Schad &amp; Dima 2020 is available via this <a href="https://rdcu.be/b5J2X">link</a>.</p>
<p>A read-only Enhanced PDF version of Schad &amp; Dima 2021, regarding symmetry-breaking effects, is available via this <a href="https://rdcu.be/cBp1o">link</a>.</p>
<p>The original code developed by <a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract">Schad &amp; Dima 2020</a> (previously referred to as pyCLE) was a Fortran based code wrapped in python.
pyCELP is a completely new implementation coded entirely in Python.
It takes advantage of specific algorithm changes, numba jit compilers, and efficient numpy linear algebra packages to provide excellent speed performance that in most cases exceeds the earlier code.
More information pertaining to numba is below.</p>
<h2 id="citing-pycelp">Citing pyCELP</h2>
<p>If you use pyCELP, please reference <a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract">Schad &amp; Dima (2020)</a>. pyCELP is listed on the <a href="https://ascl.net/2112.001">Astrophysics Source Code Library (ASCL)</a> registry and its bibcode can be found on <a href="https://ui.adsabs.harvard.edu/abs/2021ascl.soft12001S/abstract">NASA/ADS</a>.</p>
<p>Further references for the polarized theory include <a href="https://ui.adsabs.harvard.edu/abs/1999ApJ...522..524C/abstract">Casini &amp; Judge (1999)</a> and <a href="https://link.springer.com/book/10.1007/1-4020-2415-0">Landi Degl’innocenti &amp;
Landolfi (2004)</a>.</p>
<h2 id="install">Install</h2>
<h3 id="dependencies">Dependencies</h3>
<ul>
<li>python3, numpy, numba</li>
<li>(optional - for tests/examples) matplotlib, scipy, jupyter</li>
<li>(optional - for updating docs) pdoc3</li>
<li>The <a href="http://www.chiantidatabase.org/chianti_download.html">CHIANTI atomic database</a> is also required.
Originally, this code was developed with Chianti v9; however, it is now upgraded to use Chianti v10.
Chianti v9 should still work; however, there have been modifications in particular to the Si IX model that the update version and its example codes assume. pyCELP will automatically search for the Chianti atomic database path using the default environment variable XUVTOP.</li>
</ul>
<h3 id="conda-environment">Conda environment</h3>
<p>It is recommended to install pycelp within a conda environment.
For the best performance, it is recommended to use a version of numpy with an optimal linear algebra library, e.g. MKL for intel compilers (<a href="https://numpy.org/install/#numpy-packages--accelerated-linear-algebra-libraries">https://numpy.org/install/#numpy-packages--accelerated-linear-algebra-libraries</a>).</p>
<p>Example:</p>
<pre><code class="language-shell">$ conda create --name pycelp
$ conda activate pycelp
$ conda install python numpy scipy numba matplotlib
</code></pre>
<h3 id="downloadclone-repo">Download/clone repo</h3>
<pre><code class="language-shell">$ git clone https://github.com/tschad/pycelp.git
$ cd pycelp
$ python setup.py develop  
</code></pre>
<p>Once the pyclep package is cloned or downloaded into a directory, it can be installed with the provided setup script either in develop or install mode.
The above shows the develop mode installation which is useful when adding to the code. </p>
<h2 id="examples">Examples</h2>
<p>Below is a minimal example of using the pycelp code from a python terminal.
For
more extensive examples, see those provided in the examples subdirectory
within the project repo.</p>
<p>A tour of the main class can be seen in <a href="https://github.com/tschad/pycelp/blob/main/examples/A_tour_of_the_Ion_class.ipynb">this notebook</a>.</p>
<pre><code class="language-shell">(juplab) [schad@Schad-Mac pycelp]$ python
Python 3.9.4 (default, Apr  9 2021, 09:32:38)
[Clang 10.0.0 ] :: Anaconda, Inc. on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pycelp
&gt;&gt;&gt; fe13 = pycelp.Ion('fe_13',nlevels = 50)
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.elvlc
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.wgfa
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.scups
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.psplups
 using default abundances: /usr/local/ssw/packages/chianti/dbase/abundance/sun_photospheric_2009_asplund.abund
 reading:  /usr/local/ssw/packages/chianti/dbase/abundance/sun_photospheric_2009_asplund.abund
 testing default file: /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
 reading:  /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
 setting up electron collision rate factors
 setting up proton  collision rate factors
 setting up non-dipole radiative rate factors
 getting non-dipole rate factors
 setting up dipole radiative rate factors
&gt;&gt;&gt;
&gt;&gt;&gt; fe13
pyCELP Ion class
    ---------------------
    Ion Name: fe_13
    Number of energy levels included: 50
    Number of SEE equations: 142
    Number of Radiative Transitions: 366
    Ionization Equilbrium Filename: /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
&gt;&gt;&gt;
</code></pre>
<h2 id="numba-implementation-and-options">Numba implementation and options</h2>
<p>pyCELP uses numba @njit decorators for jit compiling many portions of the codebase.
In most instances, the code adopts a file-based cache for storing compiled versions of the code for later use.
The first time pyCELP is used, there is additional overhead in the time required to compile the code.
Subsequent calls are significantly faster.
If one makes modifications to the code and errors occur, it may be advised to delete the cached files the __pycache__ directory of the installed package.</p>
<p>The code does not use numba parallel options for multithreading.</p>
<p>Numba can be disabled through the use of an environmental variable (NUMBA_DISABLE) but this is not frequently used.</p>
<h2 id="numpy-libraries-for-multiprocessing">Numpy libraries for multiprocessing</h2>
<p>pyCELP uses numpy libraries which can have multithreaded modules.
If pyCELP is used in a multiprocessor application, threads need to be properly managed.</p>
<h2 id="updating-documentation">Updating documentation</h2>
<p>Code reference documentation is available at <a href="https:://tschad.github.io/pycelp">tschad.github.io/pycelp</a>.
These are created using pdoc3.
They are easily manually built and/or updated from the main project repo directory by using the following command.
</p>
<pre><code class="language-shell">pdoc --html --force --output-dir docs pycelp
</code></pre>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>pyCELP evolved from work initially using the CLE code developed by Phil Judge and Roberto Casini at the High Altitude Observatory.
While pyCELP is now a completely independent implementation, we express our gratitude for all we learned by using CLE.
pyCELP has been developed based on the excellent treatise on spectral line polarization by Egidio Landi Degl’innocenti and Marco Landolfi available <a href="https://link.springer.com/book/10.1007/1-4020-2415-0">here</a>.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pycelp.allenSolRad" href="allenSolRad.html">pycelp.allenSolRad</a></code></dt>
<dd>
<div class="desc"><p>Provides access to solar spectral distribution information available in Allen's
Astrophysical Quantities 4th Edition (Section 14.6), including disk …</p></div>
</dd>
<dt><code class="name"><a title="pycelp.chianti" href="chianti.html">pycelp.chianti</a></code></dt>
<dd>
<div class="desc"><p>This module provides read routines necessary for interfacing with the Chianti
database ascii files.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.collisions" href="collisions.html">pycelp.collisions</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating collisional rate
coefficients.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.dipoles" href="dipoles.html">pycelp.dipoles</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating radiative rate
coefficients for dipole transitions.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.emissionLine" href="emissionLine.html">pycelp.emissionLine</a></code></dt>
<dd>
<div class="desc"><p>This module contains the emissionLine class for pycelp.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.ion" href="ion.html">pycelp.ion</a></code></dt>
<dd>
<div class="desc"><p>This module contains the Ion class for pycelp.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.non_dipoles" href="non_dipoles.html">pycelp.non_dipoles</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating radiative rate
coefficients for non-dipole transitions.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.util" href="util.html">pycelp.util</a></code></dt>
<dd>
<div class="desc"><p>This module provides main utility functions needed by pycelp.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.wigner" href="wigner.html">pycelp.wigner</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions to calculate Wigner 3j, 6j, and 9j symbols.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycelp.Ion"><code class="flex name class">
<span>class <span class="ident">Ion</span></span>
<span>(</span><span>ion_name, nlevels=None, ioneqFile=None, abundFile=None, all_ks=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The ion object is the primary class used by pycelp for calculations of the
polarized emission for a particular transition. Upon initialization, an Ion
object loads all necessary atomic data from the CHIANTI database and
pre-calculates all pre-factors and static terms of the statistical
equilibrium rate equations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ion_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of ion (e.g., 'fe_13')</dd>
<dt><strong><code>nlevels</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>Number of energy levels to include (default is all)</dd>
<dt><strong><code>ioneqFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Ionization equilibrium filename (defaults to Chianti default file)</dd>
<dt><strong><code>abundFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Abundance filename (defaults to sun_photospheric_2009_asplund.abund)</dd>
<dt><strong><code>all_ks</code></strong> :&ensp;<code>bool (default = False)</code></dt>
<dd>Flag to include all multipole order Ks in the calculation
The default is to include only the even values of K for the no
coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.</dd>
</dl>
<h2 id="references">References</h2>
<p>Egidio Landi Degl’innocenti and Marco Landolfi (2004)
"Polarization in Spectral Lines"
<a href="https://link.springer.com/book/10.1007/1-4020-2415-0">https://link.springer.com/book/10.1007/1-4020-2415-0</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ion:
    &#34;&#34;&#34;
    The ion object is the primary class used by pycelp for calculations of the
    polarized emission for a particular transition. Upon initialization, an Ion
    object loads all necessary atomic data from the CHIANTI database and
    pre-calculates all pre-factors and static terms of the statistical
    equilibrium rate equations.

    Parameters
    ----------
    ion_name : str
        Name of ion (e.g., &#39;fe_13&#39;)
    nlevels:  int (default = None)
        Number of energy levels to include (default is all)
    ioneqFile : str (default = None)
        Ionization equilibrium filename (defaults to Chianti default file)
    abundFile : str (default = None)
        Abundance filename (defaults to sun_photospheric_2009_asplund.abund)
    all_ks : bool (default = False)
        Flag to include all multipole order Ks in the calculation
        The default is to include only the even values of K for the no
        coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.

    References
    ----------
    Egidio Landi Degl’innocenti and Marco Landolfi (2004)
    &#34;Polarization in Spectral Lines&#34;
    &lt;https://link.springer.com/book/10.1007/1-4020-2415-0&gt;

    &#34;&#34;&#34;

    def __init__(self, ion_name,nlevels=None,ioneqFile=None,
                abundFile=None,all_ks = False):

        ## READ CHIANTI ATOMIC DATA
        elvl_data    = elvlcRead(ion_name)   ## ENERGY LEVEL DATA
        wgfa_data    = wgfaRead(ion_name)    ## RADIATIVE TRANSITION DATA
        scups_data   = scupsRead(ion_name)   ## ELECTRON COLLISIONAL DATA
        splups_data  = splupsRead(ion_name)  ## PROTON COLLISIONAL DATA
        abund_data   = abundRead(abundFile)     ## not selectable yet
        ioneq_data   = ioneqRead(&#39;temp&#39;)     ## not selectable yet

        ### REDUCE NUMBER OF CONSIDERED LEVELS
        if nlevels != None:
            elvl_data  = limit_levels(elvl_data,nlevels,type = &#39;elvl&#39;)
            wgfa_data  = limit_levels(wgfa_data,nlevels,type = &#39;wgfa&#39;)
            scups_data = limit_levels(scups_data,nlevels,type = &#39;scups&#39;)
            splups_data = limit_levels(splups_data,nlevels,type = &#39;splups&#39;)

        nlevels     = len(elvl_data[&#39;energy&#39;])

        ### DERIVE NECESSARY ATOMIC PARAMETERS
        element, ion_stage = ion_name.split(&#39;_&#39;)
        ion_stage     = int(ion_stage)
        ionZ          = getIonZ(ion_name)
        atomicWeight  = getAtomicWeight(element)
        element_abund = abund_data[&#39;abund_val&#39;][np.where(abund_data[&#39;abund_z&#39;] == ionZ)][0]
        eq_logtemp    = np.copy(ioneq_data[&#39;temp&#39;])
        eq_frac       = np.copy(ioneq_data[&#39;ionfrac&#39;][:,ionZ-1,ion_stage-1]).clip(1.e-30)
        eq_logfrac    = np.log10(eq_frac)
        yderiv2       = util.new_second_derivative(eq_logtemp,eq_logfrac,1e100,1e100)
        qnj           = elvl_data[&#39;j&#39;]

        ######### SETUP INDICES OF THE SEE MATRIX AND GET WEIGHTS
        see_neq,see_index,see_lev,see_k,see_dk = util.setupSEE(qnj,all_ks=all_ks)
        weight = np.zeros(see_neq)
        weight[see_k == 0] =  np.sqrt((2.*qnj[see_lev[see_k == 0]]+1))

        ######### ELECTRON COLLISION RATE INITIALIZATION CALCULATIONS
        ## precalculate the spline interpolations
        scups_data[&#39;yd2&#39;] = getSecondDerivatives(scups_data[&#39;bt_t&#39;],scups_data[&#39;bt_upsilon&#39;],scups_data[&#39;n_t&#39;])
        ettype = util.get_eTransType(elvl_data,scups_data)
        elowlev = scups_data[&#39;lower_level_index&#39;]-1
        eupplev = scups_data[&#39;upper_level_index&#39;]-1
        print(&#39; setting up electron collision rate factors&#39;)
        ciK,ciK_indx,csK,csK_indx = setup_ecoll(elowlev,eupplev,ettype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### PROTON COLLISION RATE INITIALIZATION CALCULATIONS
        splups_data[&#39;yd2&#39;] = getSecondDerivatives(splups_data[&#39;bt_t&#39;],splups_data[&#39;bt_upsilon&#39;],splups_data[&#39;n_t&#39;])
        plowlev = splups_data[&#39;lower_level_index&#39;]-1
        pupplev = splups_data[&#39;upper_level_index&#39;]-1
        pttype = np.zeros(len(plowlev)) - 1
        print(&#39; setting up proton  collision rate factors&#39;)
        ciKp,ciKp_indx,csKp,csKp_indx = setup_ecoll(plowlev,pupplev,pttype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### RADIATIVE RATES INITIALIZATION CALCULATIONS

        rupplev = wgfa_data[&#39;upper_level_index&#39;]-1
        rlowlev = wgfa_data[&#39;lower_level_index&#39;]-1
        gup    = 2*qnj[rupplev]+1
        glo    = 2*qnj[rlowlev]+1
        alamb  = 1.e8 / (elvl_data[&#39;energy&#39;][rupplev] - elvl_data[&#39;energy&#39;][rlowlev])
        a_up2low = wgfa_data[&#39;A_einstein&#39;]
        hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
        cc = 2.99792458e10 ## cm s^-1 (speed of light)
        b_up2low = (alamb**3)/2./hh/cc/1.e24*a_up2low
        b_low2up = gup/glo*b_up2low
        nrad = len(rlowlev)

        wv_air = util.vac2air(alamb)

        ### DERIVE D and E coefficients
        ss,ll,jj = elvl_data[&#39;s&#39;],elvl_data[&#39;l&#39;],elvl_data[&#39;j&#39;]
        landeg = util.calcLande(jj,ss,ll)
        Jupp,Jlow = jj[rupplev],jj[rlowlev]
        gupp,glow = landeg[rupplev],landeg[rlowlev]
        Dcoeff = util.getDcoeff(Jupp,Jlow)
        Ecoeff = util.getEcoeff(Jupp,Jlow,gupp,glow)
        geff = 0.5*(glow+gupp) + 0.25 * (glow-gupp) * (Jlow*(Jlow+1.) - Jupp*(Jupp+1.))
        
        ## --&gt; Non-dipoles
        print(&#39; setting up non-dipole radiative rate factors&#39;)
        tnD,tnD_indx,nonD_spon= setup_nonDipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,
                                                b_up2low,see_index,see_lev,see_k,see_dk)

        ## ---&gt; Dipoles
        print(&#39; setting up dipole radiative rate factors&#39;)
        tD,tD_indx,Dmat_spon = setup_Dipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,b_up2low,see_index,see_lev,see_k,see_dk)

        #################################################
        ## put into instance information
        self.ion_name = ion_name
        self.all_ks = all_ks
        ########################
        self.nlevels = nlevels
        self.elvl_data    = elvl_data
        self.landeg       = landeg
        self.wgfa_data    = wgfa_data
        self.scups_data   = scups_data
        self.splups_data  = splups_data
        self.abund_data   = abund_data
        self.ioneq_data   = ioneq_data
        ########################
        self.element = element
        self.ion_stage = ion_stage
        self.ionZ = ionZ
        self.atomicWeight = atomicWeight
        self.element_abund = element_abund
        self.ioneq_logtemp = eq_logtemp
        self.ioneq_frac    = eq_frac
        self.ioneq_logfrac = eq_logfrac
        self.ioneq_yderiv2 = yderiv2
        self.qnj = qnj
        ########################
        self.see_neq    = see_neq
        self.see_index  = see_index
        self.see_lev    = see_lev
        self.see_k      = see_k
        self.see_dk     = see_dk
        self.weight     = weight
        ########################
        self.scups_data = scups_data
        self.elowlev    = elowlev
        self.eupplev    = eupplev
        self.ciK        = ciK
        self.ciK_indx   = ciK_indx
        self.csK        = csK
        self.csK_indx   = csK_indx
        ########################
        self.splups_data = splups_data
        self.plowlev     = plowlev
        self.pupplev     = pupplev
        self.ciKp        = ciKp
        self.ciKp_indx   = ciKp_indx
        self.csKp        = csKp
        self.csKp_indx   = csKp_indx
        ########################
        ## radiative transition info
        self.rlowlev    = rlowlev
        self.rupplev    = rupplev
        self.Dcoeff     = Dcoeff
        self.Ecoeff     = Ecoeff
        self.geff       = geff
        self.alamb      = alamb
        self.wv_air     = wv_air
        self.a_up2low   = a_up2low
        self.b_up2low   = b_up2low
        self.b_low2up   = b_low2up
        self.tnD        = tnD
        self.tnD_indx   = tnD_indx
        self.nonD_spon  = nonD_spon
        self.tD         = tD
        self.tD_indx    = tD_indx
        self.Dmat_spon  = Dmat_spon

    def __repr__(self):
         return f&#34;&#34;&#34;pyCELP Ion class
    ---------------------
    Ion Name: {self.ion_name}
    Number of energy levels included: {self.nlevels}
    Number of SEE equations: {self.see_neq}
    Number of Radiative Transitions: {len(self.alamb)}
    Ionization Equilbrium Filename: {self.ioneq_data[&#39;filename&#39;]}&#34;&#34;&#34;

    def get_maxtemp(self):
        &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
        logt = np.linspace(5,7,50)
        eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        logt_max = logt[np.argmax(eq_frac_int)]
        return 10.**logt_max

    def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                    include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) for the
        case of a cylindrically symmetric radiation field.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        height : float (units: fraction of a solar radius)
            Height above the solar photosphere
        thetab : float (units: degrees)
            Inclination angle of the magnetic field relative to the solar
            vertical (i.e. 0 == vertical, 90 = horizontal)

        Other Parameters
        ----------
        include_limbdark:  bool (default: True)
            Flag to include limb darkening in the radiation field calculation
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;
        thetab = np.deg2rad(thetab)
        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth
        self.thetab_rad = thetab

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens)

        self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_rho_radj(self,edens,etemp,radj,include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) in the case
        that the radiation field tensor components are given as a input.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        radj : float,nparray (shape is (3, number of radiative transitions))
            Radiation field tensor components (QK = 00,01,02) for all
            radiative transitions in the ion

        Other Parameters
        ----------
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;

        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.etemp = etemp 
        self.pdens = pdens
        self.toth  = toth

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens) 
        
        self.radj    = radj

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_ecoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        ecmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return ecmat_std

    def calc_pcoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        pcmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return pcmat_std

    def calc_dipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        Dmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return Dmat_std

    def calc_nonDipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        nonDmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return nonDmat_std

    def calc_rad_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        DD = nonDmat + Dmat
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        radmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return radmat_std
    
    def show_lines(self,nlines=None,start=0):
        &#34;&#34;&#34; prints out information for the radiative transitions

        Parameters
        ----------
        nlines : int (default = None)
            The number of spectral lines to print
        start:  int (default = 0)
            Starting index of lines printed.
            Lines are ordered roughly by energy level indices
        &#34;&#34;&#34;

        if (nlines == None):
            nlines = len(self.alamb)
            start = 0

        assert start &gt;= 0
        assert start &lt;= len(self.alamb)
        assert nlines &lt;= len(self.alamb)
        print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
        for ln in range(start,start+nlines):
            wv = np.round(self.alamb[ln],3)
            wvair = np.round(self.wv_air[ln],3)
            upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
            print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])

    def energy_levels_to_dataframe(self): 
        &#34;&#34;&#34; Converts Chianti Energy Level information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Energy Level Information to dataframe requires pandas package to be installed&#39;)
            
        energy_units = self.elvl_data[&#39;energy_units&#39;]
        
        d = {&#39;Index&#39;      : self.elvl_data[&#39;index&#39;], 
             &#39;Ion_name&#39;   : np.repeat(self.ion_name,self.nlevels),
             &#39;Ion_z&#39;      : np.repeat(self.elvl_data[&#39;ion_z&#39;],self.nlevels),
             &#39;Config&#39;     : self.elvl_data[&#39;conf&#39;], 
             &#39;Conf Idx&#39; : self.elvl_data[&#39;conf_index&#39;],
             &#39;Term&#39;       : self.elvl_data[&#39;term&#39;], 
             &#39;Level&#39;      : self.elvl_data[&#39;level&#39;], 
             &#39;Full Level&#39; : self.elvl_data[&#39;full_level&#39;],
             &#39;Spin Mult&#39;  : self.elvl_data[&#39;mult&#39;],
             &#39;S&#39;       : self.elvl_data[&#39;s&#39;],
             &#39;L&#39;       : self.elvl_data[&#39;l&#39;],
             &#39;Orbital&#39; : self.elvl_data[&#39;l_sym&#39;],
             &#39;J&#39;      : self.elvl_data[&#39;j&#39;],
             &#39;Lande g&#39; : self.landeg,
             &#39;Parity&#39; : self.elvl_data[&#39;parity&#39;],
             &#39;Parity Str&#39; : self.elvl_data[&#39;parity_str&#39;],
             &#39;Stat. Weight&#39;  : self.elvl_data[&#39;weight&#39;],
             &#39;Obs Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;obs_energy&#39;],
             &#39;Theory Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;theory_energy&#39;],
             &#39;Energy [&#39; + energy_units + &#39;]&#39; : self.elvl_data[&#39;energy&#39;]}
 
        return pd.DataFrame(data=d)
    
    
    def rad_transitions_to_dataframe(self): 
        &#34;&#34;&#34; Converts Radiative Transition information to a Pandas dataframe &#34;&#34;&#34;
        
        try: 
            import pandas as pd
        except: 
            print(&#39; To convert Radiative Transition Information to dataframe requires pandas package to be installed&#39;)
            
        d = {&#39;Lambda Vac [A]&#39; : self.alamb,
             &#39;Lambda Air [A]&#39; : self.wv_air,
             &#39;UppLev Idx&#39;     : self.rupplev +1,
             &#39;LowLev Idx&#39;     : self.rlowlev +1,
             &#39;Upper Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rupplev],
             &#39;Lower Level&#39;    : self.elvl_data[&#39;full_level&#39;][self.rlowlev],
             &#39;geff [LS]&#39;      : self.geff, 
             &#39;D coeff&#39;        : self.Dcoeff,
             &#39;E coeff&#39;        : self.Ecoeff,
             &#39;Einstein A&#39;     : self.a_up2low} 
        
        return pd.DataFrame(data=d)
    
    def get_emissionLine(self,wv_air): 
        &#34;&#34;&#34; Returns an instance of the emissionLine class that contains all information needed to synthesize the line 
        
        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line (approximate - only needs to be close) 
        &#34;&#34;&#34;
        line = emissionLine(self,wv_air)
        return line </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycelp.Ion.calc_dipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_dipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
</dd>
<dt id="pycelp.Ion.calc_ecoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_ecoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
</dd>
<dt id="pycelp.Ion.calc_nonDipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_nonDipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
</dd>
<dt id="pycelp.Ion.calc_pcoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_pcoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
</dd>
<dt id="pycelp.Ion.calc_rad_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_rad_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
</dd>
<dt id="pycelp.Ion.calc_rho_radj"><code class="name flex">
<span>def <span class="ident">calc_rho_radj</span></span>(<span>self, edens, etemp, radj, include_protons=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the elements of the atomic density matrix (rho) in the case
that the radiation field tensor components are given as a input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edens</code></strong> :&ensp;<code>float (units: cm^-3)</code></dt>
<dd>Electron density (e.g., 1e8)</dd>
<dt><strong><code>etemp</code></strong> :&ensp;<code>float (units: K)</code></dt>
<dd>Electron temperature (e.g., 1.e6)</dd>
<dt><strong><code>radj</code></strong> :&ensp;<code>float,nparray (shape is (3, number</code> of <code>radiative transitions))</code></dt>
<dd>Radiation field tensor components (QK = 00,01,02) for all
radiative transitions in the ion</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_protons</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flat to include protons in the collisional rates</dd>
</dl></div>
</dd>
<dt id="pycelp.Ion.calc_rho_sym"><code class="name flex">
<span>def <span class="ident">calc_rho_sym</span></span>(<span>self, edens, etemp, height, thetab, include_limbdark=True, include_protons=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the elements of the atomic density matrix (rho) for the
case of a cylindrically symmetric radiation field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edens</code></strong> :&ensp;<code>float (units: cm^-3)</code></dt>
<dd>Electron density (e.g., 1e8)</dd>
<dt><strong><code>etemp</code></strong> :&ensp;<code>float (units: K)</code></dt>
<dd>Electron temperature (e.g., 1.e6)</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float (units: fraction</code> of <code>a solar radius)</code></dt>
<dd>Height above the solar photosphere</dd>
<dt><strong><code>thetab</code></strong> :&ensp;<code>float (units: degrees)</code></dt>
<dd>Inclination angle of the magnetic field relative to the solar
vertical (i.e. 0 == vertical, 90 = horizontal)</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_limbdark</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flag to include limb darkening in the radiation field calculation</dd>
<dt><strong><code>include_protons</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flat to include protons in the collisional rates</dd>
</dl></div>
</dd>
<dt id="pycelp.Ion.energy_levels_to_dataframe"><code class="name flex">
<span>def <span class="ident">energy_levels_to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Chianti Energy Level information to a Pandas dataframe</p></div>
</dd>
<dt id="pycelp.Ion.get_emissionLine"><code class="name flex">
<span>def <span class="ident">get_emissionLine</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an instance of the emissionLine class that contains all information needed to synthesize the line </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line (approximate - only needs to be close)</dd>
</dl></div>
</dd>
<dt id="pycelp.Ion.get_maxtemp"><code class="name flex">
<span>def <span class="ident">get_maxtemp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the temperature at maximum ionization fraction in Kelvin</p></div>
</dd>
<dt id="pycelp.Ion.rad_transitions_to_dataframe"><code class="name flex">
<span>def <span class="ident">rad_transitions_to_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts Radiative Transition information to a Pandas dataframe</p></div>
</dd>
<dt id="pycelp.Ion.show_lines"><code class="name flex">
<span>def <span class="ident">show_lines</span></span>(<span>self, nlines=None, start=0)</span>
</code></dt>
<dd>
<div class="desc"><p>prints out information for the radiative transitions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nlines</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>The number of spectral lines to print</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>int (default = 0)</code></dt>
<dd>Starting index of lines printed.
Lines are ordered roughly by energy level indices</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#about-the-code">About the code</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#citing-pycelp">Citing pyCELP</a></li>
<li><a href="#install">Install</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#conda-environment">Conda environment</a></li>
<li><a href="#downloadclone-repo">Download/clone repo</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#numba-implementation-and-options">Numba implementation and options</a></li>
<li><a href="#numpy-libraries-for-multiprocessing">Numpy libraries for multiprocessing</a></li>
<li><a href="#updating-documentation">Updating documentation</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pycelp.allenSolRad" href="allenSolRad.html">pycelp.allenSolRad</a></code></li>
<li><code><a title="pycelp.chianti" href="chianti.html">pycelp.chianti</a></code></li>
<li><code><a title="pycelp.collisions" href="collisions.html">pycelp.collisions</a></code></li>
<li><code><a title="pycelp.dipoles" href="dipoles.html">pycelp.dipoles</a></code></li>
<li><code><a title="pycelp.emissionLine" href="emissionLine.html">pycelp.emissionLine</a></code></li>
<li><code><a title="pycelp.ion" href="ion.html">pycelp.ion</a></code></li>
<li><code><a title="pycelp.non_dipoles" href="non_dipoles.html">pycelp.non_dipoles</a></code></li>
<li><code><a title="pycelp.util" href="util.html">pycelp.util</a></code></li>
<li><code><a title="pycelp.wigner" href="wigner.html">pycelp.wigner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycelp.Ion" href="#pycelp.Ion">Ion</a></code></h4>
<ul class="">
<li><code><a title="pycelp.Ion.calc_dipole_matrix_standard" href="#pycelp.Ion.calc_dipole_matrix_standard">calc_dipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_ecoll_matrix_standard" href="#pycelp.Ion.calc_ecoll_matrix_standard">calc_ecoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_nonDipole_matrix_standard" href="#pycelp.Ion.calc_nonDipole_matrix_standard">calc_nonDipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_pcoll_matrix_standard" href="#pycelp.Ion.calc_pcoll_matrix_standard">calc_pcoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_rad_matrix_standard" href="#pycelp.Ion.calc_rad_matrix_standard">calc_rad_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_rho_radj" href="#pycelp.Ion.calc_rho_radj">calc_rho_radj</a></code></li>
<li><code><a title="pycelp.Ion.calc_rho_sym" href="#pycelp.Ion.calc_rho_sym">calc_rho_sym</a></code></li>
<li><code><a title="pycelp.Ion.energy_levels_to_dataframe" href="#pycelp.Ion.energy_levels_to_dataframe">energy_levels_to_dataframe</a></code></li>
<li><code><a title="pycelp.Ion.get_emissionLine" href="#pycelp.Ion.get_emissionLine">get_emissionLine</a></code></li>
<li><code><a title="pycelp.Ion.get_maxtemp" href="#pycelp.Ion.get_maxtemp">get_maxtemp</a></code></li>
<li><code><a title="pycelp.Ion.rad_transitions_to_dataframe" href="#pycelp.Ion.rad_transitions_to_dataframe">rad_transitions_to_dataframe</a></code></li>
<li><code><a title="pycelp.Ion.show_lines" href="#pycelp.Ion.show_lines">show_lines</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
