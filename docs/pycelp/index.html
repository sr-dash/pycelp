<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pycelp API documentation</title>
<meta name="description" content="About the code â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pycelp</code></h1>
</header>
<section id="section-intro">
<h2 id="about-the-code">About the code</h2>
<p><a href="https://github.com/tschad/pycelp"><img alt="github" src="https://img.shields.io/badge/GitHub-tschad%2FpyCELP-blue.svg?style=flat"></a>
<a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract"><img alt="ADS" src="https://img.shields.io/badge/NASA%20ADS-SoPh%2C%20V295%2C%207%2C%2098-red"></a></p>
<p>A <strong>py</strong>thon package for <strong>C</strong>oronal <strong>E</strong>mission <strong>L</strong>ine <strong>P</strong>olarization calculations.</p>
<p>Lead Developer: T. Schad - National Solar Observatory</p>
<p><strong>DISCLAIMER: pycelp is still in the early stages of development. Contributors are welcome. </strong></p>
<h2 id="introduction">Introduction</h2>
<p>pyCELP is used to forward synthesize the polarized emission of ionized atoms formed in the solar corona.
It calculates the atomic density matrix elements for a single ion under coronal equilibrium conditions and excited by a prescribed radiation field and thermal collisions.
In its initial release, pyCELP solves a set of statistical equilibrium equations in the spherical statistical tensor respresentation for a multi-level atom for the no-coherence case.
This approximation is useful in the case of forbidden line emission by visible and infrared lines, such as Fe XIII 1074.7 nm and Si X 3.9 um.
See
<a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract">Schad &amp; Dima 2020</a> for more details and specific references.</p>
<p>A read-only Enhanced PDF version of Schad &amp; Dima 2020 is available via this <a href="https://rdcu.be/b5J2X">link</a>.</p>
<p>The original code developed by <a href="https://ui.adsabs.harvard.edu/abs/2020SoPh..295...98S/abstract">Schad &amp; Dima 2020</a> (previously referred to as pyCLE) was a Fortran based code wrapped in python.
pyCELP is a completely new implementation coded entirely in Python.
It takes advantage of specific algorithm changes, numba jit compilers, and efficient numpy linear algebra packages to provide excellent speed performance that in most cases exceeds the earlier code.
More information pertaining to numba is below.</p>
<h2 id="install">Install</h2>
<h3 id="dependencies">Dependencies</h3>
<ul>
<li>python3, numpy, numba</li>
<li>(optional - for tests/examples) matplotlib, scipy</li>
<li>(optional - for updating docs) pdoc3</li>
<li>The <a href="http://www.chiantidatabase.org/chianti_download.html">CHIANTI atomic database</a> is also required.
(Currelty tested with v9) pyCELP will automatically search for the Chianti atomic database path using the default environment variable XUVTOP.</li>
</ul>
<h3 id="conda-environment">Conda environment</h3>
<p>It is recommended to install pycelp within a conda environment.
For the best performance, it is recommended to use a version of numpy with an optimal linear algebra library, e.g. MKL for intel compilers (<a href="https://numpy.org/install/#numpy-packages--accelerated-linear-algebra-libraries">https://numpy.org/install/#numpy-packages--accelerated-linear-algebra-libraries</a>).</p>
<p>Example:</p>
<pre><code class="language-shell">$ conda create --name pycelp
$ conda activate pycelp
$ conda install python numpy scipy numba matplotlib
</code></pre>
<h3 id="downloadclone-repo">Download/clone repo</h3>
<pre><code class="language-shell">$ git clone https://github.com/tschad/pycelp.git
$ cd pycelp
$ python setup.py develop  
</code></pre>
<h2 id="examples">Examples</h2>
<p>Below is a minimal example of using the pycelp code from a python terminal.
For
more extensive examples, see those provided in the examples subdirectory
within the project repo.</p>
<pre><code class="language-shell">(juplab) [schad@Schad-Mac pycelp]$ python
Python 3.9.4 (default, Apr  9 2021, 09:32:38)
[Clang 10.0.0 ] :: Anaconda, Inc. on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import pycelp
&gt;&gt;&gt; fe13 = pycelp.Ion('fe_13',nlevels = 50)
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.elvlc
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.wgfa
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.scups
 reading:  /usr/local/ssw/packages/chianti/dbase/fe/fe_13/fe_13.psplups
 using default abundances: /usr/local/ssw/packages/chianti/dbase/abundance/sun_photospheric_2009_asplund.abund
 reading:  /usr/local/ssw/packages/chianti/dbase/abundance/sun_photospheric_2009_asplund.abund
 testing default file: /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
 reading:  /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
 setting up electron collision rate factors
 setting up proton  collision rate factors
 setting up non-dipole radiative rate factors
 getting non-dipole rate factors
 setting up dipole radiative rate factors
&gt;&gt;&gt;
&gt;&gt;&gt; fe13
pyCELP Ion class
    ---------------------
    Ion Name: fe_13
    Number of energy levels included: 50
    Number of SEE equations: 142
    Number of Radiative Transitions: 366
    Ionization Equilbrium Filename: /usr/local/ssw/packages/chianti/dbase/ioneq/chianti.ioneq
&gt;&gt;&gt;
</code></pre>
<h2 id="numba-implementation-and-options">Numba implementation and options</h2>
<p>pyCELP uses numba @njit decorators for jit compiling many portions of the codebase.
In most instances, the code adopts a file-based cache for storing compiled versions of the code for later use.
The first time pyCELP is used, there is additional overhead in the time required to compile the code.
Subsequent calls are significantly faster.
If one makes modifications to the code and errors occur, it may be advised to delete the cached files the __pycache__ directory of the installed package.</p>
<p>The code does not use numba parallel options for multithreading.</p>
<p>Numba can be disabled through the use of an environmental variable (NUMBA_DISABLE) but this is not frequently used.</p>
<h2 id="numpy-libraries-for-multiprocessing">Numpy libraries for multiprocessing</h2>
<p>pyCELP uses numpy libraries which can have multithreaded modules.
If pyCELP is used in a multiprocessor application, threads need to be properly managed.</p>
<h2 id="updating-documentation">Updating documentation</h2>
<p>Code reference documentation is available at <a href="https:://tschad.github.io/pycle">tschad.github.io/pycle</a>.
These are created using pdoc3.
They are easily manually built and/or updated from the main project repo directory by using the following command.
</p>
<pre><code class="language-shell">pdoc --html --force --output-dir docs pycelp
</code></pre>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>pyCELP evolved from work initially using the CLE code developed by Phil Judge
and Roberto Casini at the High Altitude Observatory.
While pyCELP is now a
completely independent implementation, we express our gratitude for all we
learned by using CLE.
pyCELP has been developed based on the excellent
treatise on spectral line polarization by Egidio Landi Deglâ€™innocenti and Marco
Landolfi available <a href="https://link.springer.com/book/10.1007/1-4020-2415-0">here</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../README.md
&#34;&#34;&#34;
from .ion import Ion

__all__ = [&#39;Ion&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pycelp.chianti" href="chianti.html">pycelp.chianti</a></code></dt>
<dd>
<div class="desc"><p>This module provides read routines necessary for interfacing with the Chianti
database ascii files.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.collisions" href="collisions.html">pycelp.collisions</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating collisional rate
coefficients.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.dipoles" href="dipoles.html">pycelp.dipoles</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating radiative rate
coefficients for dipole transitions.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.ion" href="ion.html">pycelp.ion</a></code></dt>
<dd>
<div class="desc"><p>This module contains the Ion class for pycelp.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.non_dipoles" href="non_dipoles.html">pycelp.non_dipoles</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions necessary for calculating radiative rate
coefficients for non-dipole transitions.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.util" href="util.html">pycelp.util</a></code></dt>
<dd>
<div class="desc"><p>This module provides main utility functions needed by pycelp.</p></div>
</dd>
<dt><code class="name"><a title="pycelp.wigner" href="wigner.html">pycelp.wigner</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions to calculate Wigner 3j, 6j, and 9j symbols.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pycelp.Ion"><code class="flex name class">
<span>class <span class="ident">Ion</span></span>
<span>(</span><span>ion_name, nlevels=None, ioneqFile=None, abundFile=None, all_ks=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The ion object is the primary class used by pycelp for calculations of the
polarized emission for a particular transition. Upon initialization, an Ion
object loads all necessary atomic data from the CHIANTI database and
pre-calculates all pre-factors and static terms of the statistical
equilibrium rate equations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ion_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of ion (e.g., 'fe_13')</dd>
<dt><strong><code>nlevels</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>Number of energy levels to include (default is all)</dd>
<dt><strong><code>ioneqFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Ionization equilibrium filename (defaults to Chianti default file)</dd>
<dt><strong><code>abundFile</code></strong> :&ensp;<code>str (default = None)</code></dt>
<dd>Abundance filename (defaults to sun_photospheric_2009_asplund.abund)</dd>
<dt><strong><code>all_ks</code></strong> :&ensp;<code>bool (default = False)</code></dt>
<dd>Flag to include all multipole order Ks in the calculation
The default is to include only the even values of K for the no
coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.</dd>
</dl>
<h2 id="references">References</h2>
<p>Egidio Landi Deglâ€™innocenti and Marco Landolfi (2004)
"Polarization in Spectral Lines"
<a href="https://link.springer.com/book/10.1007/1-4020-2415-0">https://link.springer.com/book/10.1007/1-4020-2415-0</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ion:
    &#34;&#34;&#34;
    The ion object is the primary class used by pycelp for calculations of the
    polarized emission for a particular transition. Upon initialization, an Ion
    object loads all necessary atomic data from the CHIANTI database and
    pre-calculates all pre-factors and static terms of the statistical
    equilibrium rate equations.

    Parameters
    ----------
    ion_name : str
        Name of ion (e.g., &#39;fe_13&#39;)
    nlevels:  int (default = None)
        Number of energy levels to include (default is all)
    ioneqFile : str (default = None)
        Ionization equilibrium filename (defaults to Chianti default file)
    abundFile : str (default = None)
        Abundance filename (defaults to sun_photospheric_2009_asplund.abund)
    all_ks : bool (default = False)
        Flag to include all multipole order Ks in the calculation
        The default is to include only the even values of K for the no
        coherence hypothesis, as discussed in LD&amp;L (2004) Section 13.5.

    References
    ----------
    Egidio Landi Deglâ€™innocenti and Marco Landolfi (2004)
    &#34;Polarization in Spectral Lines&#34;
    &lt;https://link.springer.com/book/10.1007/1-4020-2415-0&gt;

    &#34;&#34;&#34;

    def __init__(self, ion_name,nlevels=None,ioneqFile=None,
                abundFile=None,all_ks = False):

        ## READ CHIANTI ATOMIC DATA
        elvl_data    = elvlcRead(ion_name)   ## ENERGY LEVEL DATA
        wgfa_data    = wgfaRead(ion_name)    ## RADIATIVE TRANSITION DATA
        scups_data   = scupsRead(ion_name)   ## ELECTRON COLLISIONAL DATA
        splups_data  = splupsRead(ion_name)  ## PROTON COLLISIONAL DATA
        abund_data   = abundRead(&#39;temp&#39;)     ## not selectable yet
        ioneq_data   = ioneqRead(&#39;temp&#39;)     ## not selectable yet

        ### REDUCE NUMBER OF CONSIDERED LEVELS
        if nlevels != None:
            elvl_data  = limit_levels(elvl_data,nlevels,type = &#39;elvl&#39;)
            wgfa_data  = limit_levels(wgfa_data,nlevels,type = &#39;wgfa&#39;)
            scups_data = limit_levels(scups_data,nlevels,type = &#39;scups&#39;)
            splups_data = limit_levels(splups_data,nlevels,type = &#39;splups&#39;)

        nlevels     = len(elvl_data[&#39;energy&#39;])

        ### DERIVE NECESSARY ATOMIC PARAMETERS
        element, ion_stage = ion_name.split(&#39;_&#39;)
        ion_stage     = int(ion_stage)
        ionZ          = getIonZ(ion_name)
        atomicWeight  = getAtomicWeight(element)
        element_abund = abund_data[&#39;abund_val&#39;][np.where(abund_data[&#39;abund_z&#39;] == ionZ)][0]
        eq_logtemp    = np.copy(ioneq_data[&#39;temp&#39;])
        eq_frac       = np.copy(ioneq_data[&#39;ionfrac&#39;][:,ionZ-1,ion_stage-1]).clip(1.e-30)
        eq_logfrac    = np.log10(eq_frac)
        yderiv2       = util.new_second_derivative(eq_logtemp,eq_logfrac,1e100,1e100)
        qnj           = elvl_data[&#39;j&#39;]

        ######### SETUP INDICES OF THE SEE MATRIX AND GET WEIGHTS
        see_neq,see_index,see_lev,see_k,see_dk = util.setupSEE(qnj,all_ks=all_ks)
        weight = np.zeros(see_neq)
        weight[see_k == 0] =  np.sqrt((2.*qnj[see_lev[see_k == 0]]+1))

        ######### ELECTRON COLLISION RATE INITIALIZATION CALCULATIONS
        ## precalculate the spline interpolations
        scups_data[&#39;yd2&#39;] = getSecondDerivatives(scups_data[&#39;bt_t&#39;],scups_data[&#39;bt_upsilon&#39;],scups_data[&#39;n_t&#39;])
        ettype = util.get_eTransType(elvl_data,scups_data)
        elowlev = scups_data[&#39;lower_level_index&#39;]-1
        eupplev = scups_data[&#39;upper_level_index&#39;]-1
        print(&#39; setting up electron collision rate factors&#39;)
        ciK,ciK_indx,csK,csK_indx = setup_ecoll(elowlev,eupplev,ettype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### PROTON COLLISION RATE INITIALIZATION CALCULATIONS
        splups_data[&#39;yd2&#39;] = getSecondDerivatives(splups_data[&#39;bt_t&#39;],splups_data[&#39;bt_upsilon&#39;],splups_data[&#39;n_t&#39;])
        plowlev = splups_data[&#39;lower_level_index&#39;]-1
        pupplev = splups_data[&#39;upper_level_index&#39;]-1
        pttype = np.zeros(len(plowlev)) - 1
        print(&#39; setting up proton  collision rate factors&#39;)
        ciKp,ciKp_indx,csKp,csKp_indx = setup_ecoll(plowlev,pupplev,pttype,qnj,
                                                see_index,see_lev,see_k,see_dk)

        ######### RADIATIVE RATES INITIALIZATION CALCULATIONS

        rupplev = wgfa_data[&#39;upper_level_index&#39;]-1
        rlowlev = wgfa_data[&#39;lower_level_index&#39;]-1
        gup    = 2*qnj[rupplev]+1
        glo    = 2*qnj[rlowlev]+1
        alamb  = 1.e8 / (elvl_data[&#39;energy&#39;][rupplev] - elvl_data[&#39;energy&#39;][rlowlev])
        a_up2low = wgfa_data[&#39;A_einstein&#39;]
        hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
        cc = 2.99792458e10 ## cm s^-1 (speed of light)
        b_up2low = (alamb**3)/2./hh/cc/1.e24*a_up2low
        b_low2up = gup/glo*b_up2low
        nrad = len(rlowlev)

        wv_air = util.vac2air(alamb)

        ### DERIVE D and E coefficients
        ss,ll,jj = elvl_data[&#39;s&#39;],elvl_data[&#39;l&#39;],elvl_data[&#39;j&#39;]
        landeg = util.calcLande(jj,ss,ll)
        Jupp,Jlow = jj[rupplev],jj[rlowlev]
        gupp,glow = landeg[rupplev],landeg[rlowlev]
        Dcoeff = util.getDcoeff(Jupp,Jlow)
        Ecoeff = util.getEcoeff(Jupp,Jlow,gupp,glow)

        ## --&gt; Non-dipoles
        print(&#39; setting up non-dipole radiative rate factors&#39;)
        tnD,tnD_indx,nonD_spon= setup_nonDipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,
                                                b_up2low,see_index,see_lev,see_k,see_dk)

        ## ---&gt; Dipoles
        print(&#39; setting up dipole radiative rate factors&#39;)
        tD,tD_indx,Dmat_spon = setup_Dipoles(rlowlev,rupplev,qnj,b_low2up,a_up2low,b_up2low,see_index,see_lev,see_k,see_dk)

        #################################################
        ## put into instance information
        self.ion_name = ion_name
        self.all_ks = all_ks
        ########################
        self.nlevels = nlevels
        self.elvl_data    = elvl_data
        self.wgfa_data    = wgfa_data
        self.scups_data   = scups_data
        self.splups_data  = splups_data
        self.abund_data   = abund_data
        self.ioneq_data   = ioneq_data
        ########################
        self.element = element
        self.ion_stage = ion_stage
        self.ionZ = ionZ
        self.atomicWeight = atomicWeight
        self.element_abund = element_abund
        self.ioneq_logtemp = eq_logtemp
        self.ioneq_frac    = eq_frac
        self.ioneq_logfrac = eq_logfrac
        self.ioneq_yderiv2 = yderiv2
        self.qnj = qnj
        ########################
        self.see_neq    = see_neq
        self.see_index  = see_index
        self.see_lev    = see_lev
        self.see_k      = see_k
        self.see_dk     = see_dk
        self.weight     = weight
        ########################
        self.scups_data = scups_data
        self.elowlev    = elowlev
        self.eupplev    = eupplev
        self.ciK        = ciK
        self.ciK_indx   = ciK_indx
        self.csK        = csK
        self.csK_indx   = csK_indx
        ########################
        self.splups_data = splups_data
        self.plowlev     = plowlev
        self.pupplev     = pupplev
        self.ciKp        = ciKp
        self.ciKp_indx   = ciKp_indx
        self.csKp        = csKp
        self.csKp_indx   = csKp_indx
        ########################
        ## radiative transition info
        self.rlowlev    = rlowlev
        self.rupplev    = rupplev
        self.Dcoeff     = Dcoeff
        self.Ecoeff     = Ecoeff
        self.alamb      = alamb
        self.wv_air     = wv_air
        self.a_up2low   = a_up2low
        self.b_up2low   = b_up2low
        self.b_low2up   = b_low2up
        self.tnD        = tnD
        self.tnD_indx   = tnD_indx
        self.nonD_spon  = nonD_spon
        self.tD         = tD
        self.tD_indx    = tD_indx
        self.Dmat_spon  = Dmat_spon

    def __repr__(self):
         return f&#34;&#34;&#34;pyCELP Ion class
    ---------------------
    Ion Name: {self.ion_name}
    Number of energy levels included: {self.nlevels}
    Number of SEE equations: {self.see_neq}
    Number of Radiative Transitions: {len(self.alamb)}
    Ionization Equilbrium Filename: {self.ioneq_data[&#39;filename&#39;]}&#34;&#34;&#34;

    def get_maxtemp(self):
        &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
        logt = np.linspace(5,7,50)
        eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        logt_max = logt[np.argmax(eq_frac_int)]
        return 10.**logt_max

    def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                    include_protons = True):
        &#34;&#34;&#34;
        Calculates the elements of the atomic density matrix (rho) for the
        case of a cylindrically symmetric radiation field.

        Parameters
        ----------
        edens : float (units: cm^-3)
            Electron density (e.g., 1e8)
        etemp : float (units: K)
            Electron temperature (e.g., 1.e6)
        height : float (units: fraction of a solar radius)
            Height above the solar photosphere
        thetab : float (units: degrees)
            Inclination angle of the magnetic field relative to the solar
            vertical (i.e. 0 == vertical, 90 = horizontal)

        Other Parameters
        ----------
        include_limbdark:  bool (default: True)
            Flag to include limb darkening in the radiation field calculation
        include_protons:  bool (default: True)
            Flat to include protons in the collisional rates

        &#34;&#34;&#34;
        thetab = np.deg2rad(thetab)
        ptemp = etemp
        toth  = 0.85*edens
        pdens = 1.*toth
        if not include_protons:
            pdens = 0.

        self.edens = edens
        self.pdens = pdens
        self.toth  = toth
        self.thetab_rad = thetab

        eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
        totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

        erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                          self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                          self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                          self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                          etemp,edens)

        prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                          self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                          self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                          self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                          ptemp,pdens)

        self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

        ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                                 erates_up,erates_down,self.see_neq)
        pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                                 prates_up,prates_down,self.see_neq)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

        self.collmat = ecmat + pcmat
        self.radmat = Dmat + nonDmat
        self.see_matrix = self.collmat + self.radmat

        rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

        self.rho = rho
        self.totn = totn

    def calc_ecoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        ecmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return ecmat_std

    def calc_pcoll_matrix_standard(self):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        pcmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return pcmat_std

    def calc_dipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        Dmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return Dmat_std

    def calc_nonDipole_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        nonDmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return nonDmat_std

    def calc_rad_matrix_standard(self,ht,thetab):
        &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
        radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
        nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
        Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
        DD = nonDmat + Dmat
        wkzero = np.argwhere(self.see_k == 0)[:,0]
        radmat_std = np.zeros((self.nlevels,self.nlevels))
        for n in range(self.nlevels):
            radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
        return radmat_std

    def get_lower_level_alignment(self,wv_air):
        &#34;&#34;&#34; Returns the atomic alignment for the lower level of given transition

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        lowlev = self.rlowlev[ww]
        alignment = self.rho[lowlev,2] / self.rho[lowlev,0]
        return alignment

    def get_upper_level_alignment(self,wv_air):
        &#34;&#34;&#34; Returns the atomic alignment for the upper level of given transition

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        upplev = self.rupplev[ww]
        alignment = self.rho[upplev,2] / self.rho[upplev,0]
        return alignment

    def get_upper_level_rho00(self,wv_air):
        &#34;&#34;&#34; Returns rho(Q=0,K=0) for the upper level of given transition

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        upplev = self.rupplev[ww]
        rho00 = self.rho[upplev,0]
        return rho00

    def get_EinsteinA(self,wv_air):
        &#34;&#34;&#34; Returns the Einstein A for a selected transition

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        return self.a_up2low[ww]

    def get_Dcoeff(self,wv_air):
        &#34;&#34;&#34; Returns the D coefficent for a selected transition

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        return self.Dcoeff[ww]

    def get_Ecoeff(self,wv_air):
        &#34;&#34;&#34; Returns the E coefficent for a selected transition

        Parameters
        ----------

        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        return self.Ecoeff[ww]

    def get_Jupp(self, wv_air):
        &#34;&#34;&#34; Returns the E coefficent for a selected transition

        Parameters
        ----------

        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        upplev = self.rupplev[ww]
        return self.qnj[upplev]

    def calc_Iemiss(self,wv_air,thetaBLOS = np.rad2deg(np.arccos(1./np.sqrt(3.))) ):
        &#34;&#34;&#34; returns the intensity emission coefficent for a selected transition
        return units are photons

        Parameters
        ----------
        wv_air : float (unit: angstroms)
            Air wavelength of spectral line
        thetaBLOS : float (unit: degrees)
            inclination angle of the magnetic field relative to the line of sight
            default is van vleck
        &#34;&#34;&#34;
        ww = np.argmin(np.abs(self.wv_air - wv_air))

        if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
            print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
            print(&#39; requested: &#39;, wv_air)
            print(&#39; closest:   &#39;, self.wv_air[ww])
            raise

        upplev = self.rupplev[ww]
        Dcoeff = self.Dcoeff[ww]
        sigma = self.get_upper_level_alignment(wv_air)
        thetaBLOS = np.deg2rad(thetaBLOS)

        hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
        cc = 2.99792458e10 ## cm s^-1 (speed of light)
        hnu = hh*cc / (self.alamb[ww]/1.e8)
        Ju = self.qnj[upplev]

        ## convert units to
        sr2arcsec = (180./np.pi)**2.*3600.**2.
        phergs = hh*(3.e8)/(self.alamb[ww] * 1.e-10)
        val = hnu/4./np.pi*self.a_up2low[ww] * np.sqrt(2.*Ju+1)*self.rho[upplev,0] * self.totn
        val = val * (1. + 3./(2.*np.sqrt(2.)) * (np.cos(thetaBLOS)**2 - (1./3.)  )   )
        val = val/sr2arcsec/phergs

        return val

    def show_lines(self,nlines=None,start=0):
        &#34;&#34;&#34; prints out information for the radiative transitions

        Parameters
        ----------
        nlines : int (default = None)
            The number of spectral lines to print
        start:  int (default = 0)
            Starting index of lines printed.
            Lines are ordered roughly by energy level indices
        &#34;&#34;&#34;

        if (nlines == None):
            nlines = len(self.alamb)
            start = 0

        assert start &gt;= 0
        assert start &lt;= len(self.alamb)
        assert nlines &lt;= len(self.alamb)
        print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
        for ln in range(start,start+nlines):
            wv = np.round(self.alamb[ln],3)
            wvair = np.round(self.wv_air[ln],3)
            upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
            print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pycelp.Ion.calc_Iemiss"><code class="name flex">
<span>def <span class="ident">calc_Iemiss</span></span>(<span>self, wv_air, thetaBLOS=54.735610317245346)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the intensity emission coefficent for a selected transition
return units are photons</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
<dt><strong><code>thetaBLOS</code></strong> :&ensp;<code>float (unit: degrees)</code></dt>
<dd>inclination angle of the magnetic field relative to the line of sight
default is van vleck</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_Iemiss(self,wv_air,thetaBLOS = np.rad2deg(np.arccos(1./np.sqrt(3.))) ):
    &#34;&#34;&#34; returns the intensity emission coefficent for a selected transition
    return units are photons

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    thetaBLOS : float (unit: degrees)
        inclination angle of the magnetic field relative to the line of sight
        default is van vleck
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    upplev = self.rupplev[ww]
    Dcoeff = self.Dcoeff[ww]
    sigma = self.get_upper_level_alignment(wv_air)
    thetaBLOS = np.deg2rad(thetaBLOS)

    hh = 6.626176e-27  ## ergs sec (planck&#39;s constant);
    cc = 2.99792458e10 ## cm s^-1 (speed of light)
    hnu = hh*cc / (self.alamb[ww]/1.e8)
    Ju = self.qnj[upplev]

    ## convert units to
    sr2arcsec = (180./np.pi)**2.*3600.**2.
    phergs = hh*(3.e8)/(self.alamb[ww] * 1.e-10)
    val = hnu/4./np.pi*self.a_up2low[ww] * np.sqrt(2.*Ju+1)*self.rho[upplev,0] * self.totn
    val = val * (1. + 3./(2.*np.sqrt(2.)) * (np.cos(thetaBLOS)**2 - (1./3.)  )   )
    val = val/sr2arcsec/phergs

    return val</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_dipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_dipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_dipole_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    Dmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        Dmat_std[n,:] = Dmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return Dmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_ecoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_ecoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_ecoll_matrix_standard(self):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    ecmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        ecmat_std[n,:] = self.ecmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return ecmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_nonDipole_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_nonDipole_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_nonDipole_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    nonDmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        nonDmat_std[n,:] = nonDmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return nonDmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_pcoll_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_pcoll_matrix_standard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_pcoll_matrix_standard(self):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    pcmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        pcmat_std[n,:] = self.pcmat[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return pcmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_rad_matrix_standard"><code class="name flex">
<span>def <span class="ident">calc_rad_matrix_standard</span></span>(<span>self, ht, thetab)</span>
</code></dt>
<dd>
<div class="desc"><p>to be documented - dev use only for now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rad_matrix_standard(self,ht,thetab):
    &#34;&#34;&#34; to be documented - dev use only for now &#34;&#34;&#34;
    radj    = util.rad_field_bframe(self.alamb,thetab,ht,limbd_flag = True)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,radj,np.copy(self.nonD_spon))
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,radj,np.copy(self.Dmat_spon))
    DD = nonDmat + Dmat
    wkzero = np.argwhere(self.see_k == 0)[:,0]
    radmat_std = np.zeros((self.nlevels,self.nlevels))
    for n in range(self.nlevels):
        radmat_std[n,:] = DD[wkzero[n],wkzero] * self.weight[wkzero[n]]/self.weight[wkzero]
    return radmat_std</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.calc_rho_sym"><code class="name flex">
<span>def <span class="ident">calc_rho_sym</span></span>(<span>self, edens, etemp, height, thetab, include_limbdark=True, include_protons=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the elements of the atomic density matrix (rho) for the
case of a cylindrically symmetric radiation field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edens</code></strong> :&ensp;<code>float (units: cm^-3)</code></dt>
<dd>Electron density (e.g., 1e8)</dd>
<dt><strong><code>etemp</code></strong> :&ensp;<code>float (units: K)</code></dt>
<dd>Electron temperature (e.g., 1.e6)</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>float (units: fraction</code> of <code>a solar radius)</code></dt>
<dd>Height above the solar photosphere</dd>
<dt><strong><code>thetab</code></strong> :&ensp;<code>float (units: degrees)</code></dt>
<dd>Inclination angle of the magnetic field relative to the solar
vertical (i.e. 0 == vertical, 90 = horizontal)</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>include_limbdark</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flag to include limb darkening in the radiation field calculation</dd>
<dt><strong><code>include_protons</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Flat to include protons in the collisional rates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rho_sym(self,edens,etemp,height,thetab,include_limbdark = True,
                include_protons = True):
    &#34;&#34;&#34;
    Calculates the elements of the atomic density matrix (rho) for the
    case of a cylindrically symmetric radiation field.

    Parameters
    ----------
    edens : float (units: cm^-3)
        Electron density (e.g., 1e8)
    etemp : float (units: K)
        Electron temperature (e.g., 1.e6)
    height : float (units: fraction of a solar radius)
        Height above the solar photosphere
    thetab : float (units: degrees)
        Inclination angle of the magnetic field relative to the solar
        vertical (i.e. 0 == vertical, 90 = horizontal)

    Other Parameters
    ----------
    include_limbdark:  bool (default: True)
        Flag to include limb darkening in the radiation field calculation
    include_protons:  bool (default: True)
        Flat to include protons in the collisional rates

    &#34;&#34;&#34;
    thetab = np.deg2rad(thetab)
    ptemp = etemp
    toth  = 0.85*edens
    pdens = 1.*toth
    if not include_protons:
        pdens = 0.

    self.edens = edens
    self.pdens = pdens
    self.toth  = toth
    self.thetab_rad = thetab

    eq_frac_int  = 10.**(util.spintone(np.log10(etemp),self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
    totn         = 10.**(self.element_abund-12.)*toth*eq_frac_int

    erates_up,erates_down = intErates(self.elowlev,self.eupplev,self.qnj, \
                                      self.scups_data[&#39;delta_energy&#39;],self.scups_data[&#39;bt_c&#39;], \
                                      self.scups_data[&#39;bt_type&#39;],self.scups_data[&#39;bt_t&#39;], \
                                      self.scups_data[&#39;bt_upsilon&#39;],self.scups_data[&#39;yd2&#39;], \
                                      etemp,edens)

    prates_up,prates_down = intPrates(self.plowlev,self.pupplev,self.qnj, \
                                      self.splups_data[&#39;delta_energy&#39;],self.splups_data[&#39;bt_c&#39;], \
                                      self.splups_data[&#39;bt_type&#39;],self.splups_data[&#39;bt_t&#39;], \
                                      self.splups_data[&#39;bt_upsilon&#39;],self.splups_data[&#39;yd2&#39;], \
                                      ptemp,pdens)

    self.radj    = util.rad_field_bframe(self.alamb,thetab,height,include_limbdark = include_limbdark)

    ecmat   = getElectronSEE(self.ciK,self.ciK_indx,self.csK,self.csK_indx,
                             erates_up,erates_down,self.see_neq)
    pcmat   = getElectronSEE(self.ciKp,self.ciKp_indx,self.csKp,self.csKp_indx,
                             prates_up,prates_down,self.see_neq)
    nonDmat = getNonDipoleSEE(self.tnD,self.tnD_indx,self.radj,np.copy(self.nonD_spon))
    Dmat    = getDipoleSEE(self.tD,self.tD_indx,self.radj,np.copy(self.Dmat_spon))

    self.collmat = ecmat + pcmat
    self.radmat = Dmat + nonDmat
    self.see_matrix = self.collmat + self.radmat

    rho     = util.seeSolve(self.see_matrix,self.weight,self.see_lev,self.see_k)

    self.rho = rho
    self.totn = totn</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_Dcoeff"><code class="name flex">
<span>def <span class="ident">get_Dcoeff</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the D coefficent for a selected transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Dcoeff(self,wv_air):
    &#34;&#34;&#34; Returns the D coefficent for a selected transition

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    return self.Dcoeff[ww]</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_Ecoeff"><code class="name flex">
<span>def <span class="ident">get_Ecoeff</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the E coefficent for a selected transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Ecoeff(self,wv_air):
    &#34;&#34;&#34; Returns the E coefficent for a selected transition

    Parameters
    ----------

    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    return self.Ecoeff[ww]</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_EinsteinA"><code class="name flex">
<span>def <span class="ident">get_EinsteinA</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the Einstein A for a selected transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_EinsteinA(self,wv_air):
    &#34;&#34;&#34; Returns the Einstein A for a selected transition

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    return self.a_up2low[ww]</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_Jupp"><code class="name flex">
<span>def <span class="ident">get_Jupp</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the E coefficent for a selected transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_Jupp(self, wv_air):
    &#34;&#34;&#34; Returns the E coefficent for a selected transition

    Parameters
    ----------

    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    upplev = self.rupplev[ww]
    return self.qnj[upplev]</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_lower_level_alignment"><code class="name flex">
<span>def <span class="ident">get_lower_level_alignment</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the atomic alignment for the lower level of given transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lower_level_alignment(self,wv_air):
    &#34;&#34;&#34; Returns the atomic alignment for the lower level of given transition

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    lowlev = self.rlowlev[ww]
    alignment = self.rho[lowlev,2] / self.rho[lowlev,0]
    return alignment</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_maxtemp"><code class="name flex">
<span>def <span class="ident">get_maxtemp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the temperature at maximum ionization fraction in Kelvin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_maxtemp(self):
    &#34;&#34;&#34; Returns the temperature at maximum ionization fraction in Kelvin &#34;&#34;&#34;
    logt = np.linspace(5,7,50)
    eq_frac_int  = 10.**(util.spintarr(logt,self.ioneq_logtemp,self.ioneq_logfrac,self.ioneq_yderiv2))
    logt_max = logt[np.argmax(eq_frac_int)]
    return 10.**logt_max</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_upper_level_alignment"><code class="name flex">
<span>def <span class="ident">get_upper_level_alignment</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the atomic alignment for the upper level of given transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_upper_level_alignment(self,wv_air):
    &#34;&#34;&#34; Returns the atomic alignment for the upper level of given transition

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    upplev = self.rupplev[ww]
    alignment = self.rho[upplev,2] / self.rho[upplev,0]
    return alignment</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.get_upper_level_rho00"><code class="name flex">
<span>def <span class="ident">get_upper_level_rho00</span></span>(<span>self, wv_air)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns rho(Q=0,K=0) for the upper level of given transition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>wv_air</code></strong> :&ensp;<code>float (unit: angstroms)</code></dt>
<dd>Air wavelength of spectral line</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_upper_level_rho00(self,wv_air):
    &#34;&#34;&#34; Returns rho(Q=0,K=0) for the upper level of given transition

    Parameters
    ----------
    wv_air : float (unit: angstroms)
        Air wavelength of spectral line
    &#34;&#34;&#34;
    ww = np.argmin(np.abs(self.wv_air - wv_air))

    if ((self.wv_air[ww] - wv_air)/wv_air &gt; 0.05):
        print(&#39; warning: requested wavelength for calculation does have a good match&#39;)
        print(&#39; requested: &#39;, wv_air)
        print(&#39; closest:   &#39;, self.wv_air[ww])
        raise

    upplev = self.rupplev[ww]
    rho00 = self.rho[upplev,0]
    return rho00</code></pre>
</details>
</dd>
<dt id="pycelp.Ion.show_lines"><code class="name flex">
<span>def <span class="ident">show_lines</span></span>(<span>self, nlines=None, start=0)</span>
</code></dt>
<dd>
<div class="desc"><p>prints out information for the radiative transitions</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nlines</code></strong> :&ensp;<code>int (default = None)</code></dt>
<dd>The number of spectral lines to print</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>int (default = 0)</code></dt>
<dd>Starting index of lines printed.
Lines are ordered roughly by energy level indices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_lines(self,nlines=None,start=0):
    &#34;&#34;&#34; prints out information for the radiative transitions

    Parameters
    ----------
    nlines : int (default = None)
        The number of spectral lines to print
    start:  int (default = 0)
        Starting index of lines printed.
        Lines are ordered roughly by energy level indices
    &#34;&#34;&#34;

    if (nlines == None):
        nlines = len(self.alamb)
        start = 0

    assert start &gt;= 0
    assert start &lt;= len(self.alamb)
    assert nlines &lt;= len(self.alamb)
    print(&#39; Index -- WV_VAC [A] -- WV_AIR [A] -- TRANSITION&#39;)
    for ln in range(start,start+nlines):
        wv = np.round(self.alamb[ln],3)
        wvair = np.round(self.wv_air[ln],3)
        upplev,lowlev = self.rupplev[ln],self.rlowlev[ln]
        print(ln, wv,wvair, self.elvl_data[&#39;full_level&#39;][upplev], &#39; --&gt; &#39;, self.elvl_data[&#39;full_level&#39;][lowlev])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#about-the-code">About the code</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#install">Install</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#conda-environment">Conda environment</a></li>
<li><a href="#downloadclone-repo">Download/clone repo</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a></li>
<li><a href="#numba-implementation-and-options">Numba implementation and options</a></li>
<li><a href="#numpy-libraries-for-multiprocessing">Numpy libraries for multiprocessing</a></li>
<li><a href="#updating-documentation">Updating documentation</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pycelp.chianti" href="chianti.html">pycelp.chianti</a></code></li>
<li><code><a title="pycelp.collisions" href="collisions.html">pycelp.collisions</a></code></li>
<li><code><a title="pycelp.dipoles" href="dipoles.html">pycelp.dipoles</a></code></li>
<li><code><a title="pycelp.ion" href="ion.html">pycelp.ion</a></code></li>
<li><code><a title="pycelp.non_dipoles" href="non_dipoles.html">pycelp.non_dipoles</a></code></li>
<li><code><a title="pycelp.util" href="util.html">pycelp.util</a></code></li>
<li><code><a title="pycelp.wigner" href="wigner.html">pycelp.wigner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pycelp.Ion" href="#pycelp.Ion">Ion</a></code></h4>
<ul class="">
<li><code><a title="pycelp.Ion.calc_Iemiss" href="#pycelp.Ion.calc_Iemiss">calc_Iemiss</a></code></li>
<li><code><a title="pycelp.Ion.calc_dipole_matrix_standard" href="#pycelp.Ion.calc_dipole_matrix_standard">calc_dipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_ecoll_matrix_standard" href="#pycelp.Ion.calc_ecoll_matrix_standard">calc_ecoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_nonDipole_matrix_standard" href="#pycelp.Ion.calc_nonDipole_matrix_standard">calc_nonDipole_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_pcoll_matrix_standard" href="#pycelp.Ion.calc_pcoll_matrix_standard">calc_pcoll_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_rad_matrix_standard" href="#pycelp.Ion.calc_rad_matrix_standard">calc_rad_matrix_standard</a></code></li>
<li><code><a title="pycelp.Ion.calc_rho_sym" href="#pycelp.Ion.calc_rho_sym">calc_rho_sym</a></code></li>
<li><code><a title="pycelp.Ion.get_Dcoeff" href="#pycelp.Ion.get_Dcoeff">get_Dcoeff</a></code></li>
<li><code><a title="pycelp.Ion.get_Ecoeff" href="#pycelp.Ion.get_Ecoeff">get_Ecoeff</a></code></li>
<li><code><a title="pycelp.Ion.get_EinsteinA" href="#pycelp.Ion.get_EinsteinA">get_EinsteinA</a></code></li>
<li><code><a title="pycelp.Ion.get_Jupp" href="#pycelp.Ion.get_Jupp">get_Jupp</a></code></li>
<li><code><a title="pycelp.Ion.get_lower_level_alignment" href="#pycelp.Ion.get_lower_level_alignment">get_lower_level_alignment</a></code></li>
<li><code><a title="pycelp.Ion.get_maxtemp" href="#pycelp.Ion.get_maxtemp">get_maxtemp</a></code></li>
<li><code><a title="pycelp.Ion.get_upper_level_alignment" href="#pycelp.Ion.get_upper_level_alignment">get_upper_level_alignment</a></code></li>
<li><code><a title="pycelp.Ion.get_upper_level_rho00" href="#pycelp.Ion.get_upper_level_rho00">get_upper_level_rho00</a></code></li>
<li><code><a title="pycelp.Ion.show_lines" href="#pycelp.Ion.show_lines">show_lines</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>