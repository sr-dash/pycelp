<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pycelp.util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycelp.util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from numba import njit,jit
import numpy as np
import pycelp.wigner as wigner

## ALLEN -- lambdaCLV in Angstrom
## better to keep it as a global variable since NUMBA will know its immutable?
lambdaCLV = 1.e4* np.asarray([0.20,0.22,0.245,0.265,0.28,0.30,0.32,0.35,
                0.37,0.38,0.40,0.45,0.50,0.55,0.60,0.80,1.0,
                1.5,2.0,3.0,5.0,10.0])
uCLV = np.asarray([0.12,-1.3,-0.1,-0.1,0.38,0.74,0.88,0.98,1.03,0.92,0.91,
                    0.99,0.97,0.93,0.88,0.73,0.64,0.57,0.48,0.35,0.22,0.15])
vCLV = np.asarray([0.33,1.6,0.85,0.90,0.57, 0.20, 0.03,-0.1,-0.16,-0.05,
                    -0.05,-0.17,-0.22,-0.23,-0.23,-0.22,-0.20,-0.21,-0.18,
                    -0.12,-0.07,-0.07])

def vac2air(wvlamb):
    ww = (wvlamb &lt; 2000.)
    convl = np.zeros_like(wvlamb)
    convl[ww] = wvlamb[ww]
    ww = (wvlamb &gt;= 2000.)
    convl[ww] =  wvlamb[ww]/(1. + 2.735182e-4 + 131.4182/(wvlamb[ww]**2) + 2.76249e8/(wvlamb[ww]**4))
    return convl

@njit(cache=True)
def newint(x,a,b,u,v,up,vp):
    &#34;&#34;&#34;
    Adapted from https://arxiv.org/pdf/2001.09253.pdf
    Originally Released under a CC0 license by Haysn Hornbeck
    &#34;&#34;&#34;
    if b &lt; a:
        print(&#39;Warning: b must be &gt; a&#39;)
    ba = ( b - a )
    xa = ( x - a )
    inv_ba = 1. / ba
    bx = ( b - x )
    ba2 = ba * ba
    lower = xa * v + bx * u
    C = ( xa * xa - ba2 ) * xa * vp
    D = ( bx * bx - ba2 ) * bx * up
    return ( lower + (.16666666666666666666) *( C + D ) ) * inv_ba

@njit(cache=True)
def new_second_derivative(knots, values, start_deriv, end_deriv):
    &#34;&#34;&#34;
    Adapted from https://arxiv.org/pdf/2001.09253.pdf
    Originally Released under a CC0 license by Haysn Hornbeck
    &#34;&#34;&#34;
    n = len(knots)
    if n != len(values):
        print(&#39;warning: knots and values should have same length&#39;)
    if n &lt;= 2:
        print(&#39;warning: must have more than 2 knot value pairs&#39;)
    for i in range(1,n):
        if knots[i] &lt; knots[i-1]:
            print(&#39;knots must be sorted in increasing order&#39;)

    c_p = np.zeros(n)
    ypp = np.zeros(n)

    # recycle these values in later routines
    new_x = knots[1]
    new_y = values[1]
    cj = knots[1] - knots[0]
    new_dj = (values[1] - values[0]) / cj

    # initialize the forward substitution
    if start_deriv &gt; .99e30:
        c_p[0] = 0
        ypp[0] = 0
    else:
        c_p[0] = 0.5
        ypp[0] = 3 * ( new_dj - start_deriv ) / cj

    # forward substitution portion
    j = 1
    while j &lt; (n-1):
        # shuffle new values to old
        old_x = new_x
        old_y = new_y
        aj = cj
        old_dj = new_dj
        # generate new quantities
        new_x = knots[j+1]
        new_y = values[j+1]
        cj = new_x - old_x
        new_dj = ( new_y - old_y ) / cj
        bj = 2*(cj + aj)
        inv_denom = 1. / ( bj - aj * c_p[j-1])
        dj = 6*(new_dj - old_dj)
        ypp[j] = (dj - aj * ypp[j-1]) * inv_denom
        c_p[j] = cj * inv_denom
        j += 1

    # handle the end derivative
    if end_deriv &gt; .99e30 :
        c_p[j] = 0
        ypp[j] = 0
    else :
        old_x = new_x
        old_y = new_y
        aj = cj
        old_dj = new_dj
        cj = 0 # this has the same effect as skipping c_n
        new_dj = end_deriv
        bj = 2*(cj + aj)
        inv_denom = 1. / (bj - aj * c_p[j-1])
        dj = 6*(new_dj - old_dj)
        ypp[j] = (dj - aj * ypp [j-1]) * inv_denom
        c_p[j] = cj * inv_denom

    # as we &#39;re storing d_j in y &#39;&#39;_j , y &#39;&#39;_n = d_n is a no-op
    # backward substitution portion
    while j &gt; 0:
        j -= 1
        ypp[j] = ypp[j] - c_p[j]* ypp[j+1]

    return ypp

@njit(cache=True)
def spintarr(xnew,knots,values,ydiv2):
    ynew = np.zeros_like(xnew)
    i = 0
    for n,x in enumerate(xnew):
        while (i+1 &lt; len(knots)) and (knots[i+1] &lt; x) :
            i += 1
        ynew[n] =  newint(x,knots[i],knots[i+1],values[i],values[i+1],ydiv2[i],ydiv2[i+1])
    return ynew

@njit(cache=True)
def spintone(xnew,knots,values,ydiv2):
    i = 0
    while (i+1 &lt; len(knots)) and (knots[i+1] &lt; xnew):
        i += 1
    ynew =  newint(xnew,knots[i],knots[i+1],values[i],values[i+1],ydiv2[i],ydiv2[i+1])
    return ynew

def get_eTransType(elvl_data,scups_data):
    qns = elvl_data[&#39;s&#39;]
    qnj = elvl_data[&#39;j&#39;]
    qnl = elvl_data[&#39;l&#39;]
    iqnp = elvl_data[&#39;parity&#39;]  ## 0 == even; 1 == old parity
    lowlev = scups_data[&#39;lower_level_index&#39;]-1
    upplev = scups_data[&#39;upper_level_index&#39;]-1
    ettype = np.zeros(len(lowlev),dtype = int) -1   ## initialized all to -1
    sallow = (qns[upplev] == qns[lowlev])   ## SPIN ALLOWED?
    pallow = (iqnp[upplev] != iqnp[lowlev]) ## parity change?
    isumm  = (qnj[upplev] + qnj[lowlev]).astype(int)
    idiff  = (abs(qnj[upplev] - qnj[lowlev])).astype(int)
    wE1 = sallow * pallow * (isumm != 0) * (idiff &lt;= 1)  #E1 transitions
    wE2 = sallow * (~pallow) * (isumm &gt;= 2) * (idiff &lt;= 2) ## E2 transitions
    wM1 = sallow * (~pallow) * (isumm != 0) * (idiff &lt;= 1) ## M1 transitions
    wE1_spinchanging = (~sallow)*pallow*(isumm!=0)*(idiff&lt;=1)
    wE1_forbidden_spinchanging = (~sallow)*(~pallow)*(isumm != 0)*(idiff &lt;= 2)
    ## the order of these matter and all need to be included
    ## M1 and E2 are similar but all with idiff isumm&gt;=2 and idiff&lt;=1 are
    ## assumed to be M1
    ettype[wE1] = 1
    ettype[wE2] = 2
    ettype[wM1] = -1
    ettype[wE1_spinchanging] = -1
    ettype[wE1_forbidden_spinchanging] = -1

    return ettype

@njit(cache=True)
def rad_field_bframe(wlang,thetab,rphot,include_limbdark = True,photo_temp = 6000.):
    &#34;&#34;&#34;
    inputs:
      wlang - wavelength of transition in angstrom
      thetab - inclination of the magnetic field wrt solar vertical in radians
      rphot - height above surface in radius units
    &#34;&#34;&#34;

    nline = len(wlang)
    amu_b = np.cos(thetab)
    factor = (0.5)*(3.0*amu_b*amu_b-1.0)

    ## LANDI DEGL&#39;INNOCENTI &amp; LANDOLFI (2004) Equation 12.32
    sg = 1.0 / (1.0 + rphot)   ## sin(gamma)
    cg2 = 1.-sg**2
    cg  = np.sqrt(cg2)
    cg3 = cg2*cg
    logval = (np.log1p(sg) - np.log(cg))  ## old: np.log((1.+sg)/cg)
    b0 = (1.-cg3)/3.
    b1 = (8.*cg3 - 3.*cg2 - 2.) / 24. - cg**4 / (8.*sg) * logval
    b2 = (cg-1.)*(3.*cg3 + 6.*cg2 + 4.*cg + 2.) / (15.*(cg+1.))
    a0 = 1. - cg
    a1 = cg - 0.5 - 0.5*cg2/sg*logval
    a2 = (cg+2.)*(cg-1.) / (3.*(cg+1.))

    cc = 2.99792458e10
    hh = 6.626176e-27
    bk = 1.380662e-16

    nu = 1.e8 * (cc/wlang)
    boltzm1 = np.expm1(hh*nu/(bk*photo_temp))
    planck = 2.0*hh*(nu**3)/(cc*cc*boltzm1)

    ## NEED TO IMPLEMENT LIMB DARK FLAG HERE
    uc = np.interp(wlang,lambdaCLV,uCLV)
    vc = np.interp(wlang,lambdaCLV,vCLV)
    if not include_limbdark:
        uc = 0.*uc
        vc = 0.*vc

    Jnu = 0.5 * planck * (a0 + a1*uc + a2*vc)
    Knu = 0.5 * planck * (b0 + b1*uc + b2*vc)

    radj = np.zeros((3,nline))
    radj[0,:] = Jnu
    radj[2,:] = (3.0*Knu-Jnu)/(2.0*(2**0.5)) * factor

    return radj

@njit(cache=True)
def calcLande(J,S,L):
    ## equation 3.8 in LD&amp;L (2004)
    g = np.zeros(len(J))
    ## if J equal to zero, make lande g = 0
    g[(J == 0)] = 0.
    wg = (J != 0)
    J,S,L = J[wg],S[wg],L[wg]
    g[wg] = 1. + 0.5 * (J*(J+1) + S*(S+1) - L*(L+1)) / (J*(J+1))
    return g

@njit(cache=True)
def getDcoeff(Jupp,Jlow):
    ## D = w^(K=2)_JuJl  from equation 10.10 in LD&amp;L (2004)
    ## equation 13.28 from LD&amp;L (2004)
    nline = len(Jupp)
    d_coeff = np.zeros(nline)
    for n in range(nline):
        Ju,Jl = Jupp[n],Jlow[n]
        Ju2 = int(2*Ju)
        Jl2 = int(2*Jl)
        d_coeff[n] = (-1)**(1.+Jl+Ju) * np.sqrt(3.*(Ju2+1.)) * wigner.w6js(2,2,4,Ju2,Ju2,Jl2)
    return d_coeff

@njit(cache=True)
def getEcoeff(Jupp,Jlow,gupp,glow):
    ## D = w^(K=2)_JuJl  from equation 10.10 in LD&amp;L (2004)
    ## equation 13.28 from LD&amp;L (2004)
    nline = len(Jupp)
    e_coeff = np.zeros(nline)
    for n in range(nline):
        Ju,Jl,gu,gl = Jupp[n],Jlow[n],gupp[n],glow[n]
        Ju2 = int(2*Ju)
        Jl2 = int(2*Jl)
        factor = gu*(-1)**(1.+Jl-Ju) * np.sqrt(Ju*(Ju+1)*(Ju2+1)) * wigner.w6js(4,2,2,Ju2,Ju2,Ju2) * \
                wigner.w6js(2,2,2,Jl2,Ju2,Ju2) + \
                + gl*np.sqrt(Jl*(Jl+1)*(2.*Jl+1))*wigner.w9js(Jl2,Ju2,2,Jl2,Ju2,2,2,4,2)
        e_coeff[n] = -3.*np.sqrt(2.*Ju + 1) * factor
    return e_coeff

def setupSEE(qnj,all_ks=False):

    ## Determine the indices of the statistical equilibrium matrix elements
    ## - No-coherence hypothesis is assumed, thus Q = 0 throughout
    ## - LD&amp;L (2004) Section 13.5 discusses that K can be limited to even values.
    ##   Below, the option to use all k values remains, but it is likely not
    ##   necessary unless the code is extended to other use cases.
    ## - The total number of equations is given for the Q=0,K=even case from
    ##   the equations in Section 13.5.  For all K, each level contributes
    ##   2*J + 1 equations for each of its K values

    if all_ks:
        see_dk  = 1
        see_neq = int(np.sum(2*qnj+1))
    else:
        see_dk = 2
        if (qnj[0]%1 == 0.0):
            see_neq   = int(np.sum(qnj+1))
        else:
            see_neq   = int(np.sum(qnj+0.5))

    see_index = np.arange(see_neq)             ## index of the SEE table element
    see_lev   = np.zeros(see_neq,dtype = int)  ## energy level index
    see_k     = np.zeros(see_neq,dtype = int)  ## value of k

    nlev = len(qnj)

    i = 0
    for lev in range(nlev):
        for k in range(0,int(2*qnj[lev]+1),see_dk):
            see_lev[i] = lev
            see_k[i] = k
            i += 1

    return see_neq,see_index,see_lev,see_k,see_dk

@njit(cache=True)
def seeSolve(aa,weight,see_lev,see_k):
    &#34;&#34;&#34;
    Solves the statistical equilibrium equations
    &#34;&#34;&#34;

    ## particle conservation equation
    aa[0,:] = weight
    bb = np.zeros(weight.shape[0])
    bb[0] = 1.

    ## solve system
    xx = np.linalg.solve(aa,bb)

    ## check solution
    wk0 = (weight != 0)
    ntot = np.sum(weight[wk0]*xx[wk0])
    if (abs(1-ntot) &gt; 1.e-8):
        print(&#39;Warning:  Solution may not be accurate&#39;)

    ## reshape into rho matrix
    rho = np.zeros((max(see_lev)+1,max(see_k)+1))
    for i in range(weight.shape[0]):
        rho[see_lev[i],see_k[i]] = xx[i]

    return rho</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pycelp.util.calcLande"><code class="name flex">
<span>def <span class="ident">calcLande</span></span>(<span>J, S, L)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def calcLande(J,S,L):
    ## equation 3.8 in LD&amp;L (2004)
    g = np.zeros(len(J))
    ## if J equal to zero, make lande g = 0
    g[(J == 0)] = 0.
    wg = (J != 0)
    J,S,L = J[wg],S[wg],L[wg]
    g[wg] = 1. + 0.5 * (J*(J+1) + S*(S+1) - L*(L+1)) / (J*(J+1))
    return g</code></pre>
</details>
</dd>
<dt id="pycelp.util.getDcoeff"><code class="name flex">
<span>def <span class="ident">getDcoeff</span></span>(<span>Jupp, Jlow)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def getDcoeff(Jupp,Jlow):
    ## D = w^(K=2)_JuJl  from equation 10.10 in LD&amp;L (2004)
    ## equation 13.28 from LD&amp;L (2004)
    nline = len(Jupp)
    d_coeff = np.zeros(nline)
    for n in range(nline):
        Ju,Jl = Jupp[n],Jlow[n]
        Ju2 = int(2*Ju)
        Jl2 = int(2*Jl)
        d_coeff[n] = (-1)**(1.+Jl+Ju) * np.sqrt(3.*(Ju2+1.)) * wigner.w6js(2,2,4,Ju2,Ju2,Jl2)
    return d_coeff</code></pre>
</details>
</dd>
<dt id="pycelp.util.getEcoeff"><code class="name flex">
<span>def <span class="ident">getEcoeff</span></span>(<span>Jupp, Jlow, gupp, glow)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def getEcoeff(Jupp,Jlow,gupp,glow):
    ## D = w^(K=2)_JuJl  from equation 10.10 in LD&amp;L (2004)
    ## equation 13.28 from LD&amp;L (2004)
    nline = len(Jupp)
    e_coeff = np.zeros(nline)
    for n in range(nline):
        Ju,Jl,gu,gl = Jupp[n],Jlow[n],gupp[n],glow[n]
        Ju2 = int(2*Ju)
        Jl2 = int(2*Jl)
        factor = gu*(-1)**(1.+Jl-Ju) * np.sqrt(Ju*(Ju+1)*(Ju2+1)) * wigner.w6js(4,2,2,Ju2,Ju2,Ju2) * \
                wigner.w6js(2,2,2,Jl2,Ju2,Ju2) + \
                + gl*np.sqrt(Jl*(Jl+1)*(2.*Jl+1))*wigner.w9js(Jl2,Ju2,2,Jl2,Ju2,2,2,4,2)
        e_coeff[n] = -3.*np.sqrt(2.*Ju + 1) * factor
    return e_coeff</code></pre>
</details>
</dd>
<dt id="pycelp.util.get_eTransType"><code class="name flex">
<span>def <span class="ident">get_eTransType</span></span>(<span>elvl_data, scups_data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_eTransType(elvl_data,scups_data):
    qns = elvl_data[&#39;s&#39;]
    qnj = elvl_data[&#39;j&#39;]
    qnl = elvl_data[&#39;l&#39;]
    iqnp = elvl_data[&#39;parity&#39;]  ## 0 == even; 1 == old parity
    lowlev = scups_data[&#39;lower_level_index&#39;]-1
    upplev = scups_data[&#39;upper_level_index&#39;]-1
    ettype = np.zeros(len(lowlev),dtype = int) -1   ## initialized all to -1
    sallow = (qns[upplev] == qns[lowlev])   ## SPIN ALLOWED?
    pallow = (iqnp[upplev] != iqnp[lowlev]) ## parity change?
    isumm  = (qnj[upplev] + qnj[lowlev]).astype(int)
    idiff  = (abs(qnj[upplev] - qnj[lowlev])).astype(int)
    wE1 = sallow * pallow * (isumm != 0) * (idiff &lt;= 1)  #E1 transitions
    wE2 = sallow * (~pallow) * (isumm &gt;= 2) * (idiff &lt;= 2) ## E2 transitions
    wM1 = sallow * (~pallow) * (isumm != 0) * (idiff &lt;= 1) ## M1 transitions
    wE1_spinchanging = (~sallow)*pallow*(isumm!=0)*(idiff&lt;=1)
    wE1_forbidden_spinchanging = (~sallow)*(~pallow)*(isumm != 0)*(idiff &lt;= 2)
    ## the order of these matter and all need to be included
    ## M1 and E2 are similar but all with idiff isumm&gt;=2 and idiff&lt;=1 are
    ## assumed to be M1
    ettype[wE1] = 1
    ettype[wE2] = 2
    ettype[wM1] = -1
    ettype[wE1_spinchanging] = -1
    ettype[wE1_forbidden_spinchanging] = -1

    return ettype</code></pre>
</details>
</dd>
<dt id="pycelp.util.new_second_derivative"><code class="name flex">
<span>def <span class="ident">new_second_derivative</span></span>(<span>knots, values, start_deriv, end_deriv)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapted from <a href="https://arxiv.org/pdf/2001.09253.pdf">https://arxiv.org/pdf/2001.09253.pdf</a>
Originally Released under a CC0 license by Haysn Hornbeck</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def new_second_derivative(knots, values, start_deriv, end_deriv):
    &#34;&#34;&#34;
    Adapted from https://arxiv.org/pdf/2001.09253.pdf
    Originally Released under a CC0 license by Haysn Hornbeck
    &#34;&#34;&#34;
    n = len(knots)
    if n != len(values):
        print(&#39;warning: knots and values should have same length&#39;)
    if n &lt;= 2:
        print(&#39;warning: must have more than 2 knot value pairs&#39;)
    for i in range(1,n):
        if knots[i] &lt; knots[i-1]:
            print(&#39;knots must be sorted in increasing order&#39;)

    c_p = np.zeros(n)
    ypp = np.zeros(n)

    # recycle these values in later routines
    new_x = knots[1]
    new_y = values[1]
    cj = knots[1] - knots[0]
    new_dj = (values[1] - values[0]) / cj

    # initialize the forward substitution
    if start_deriv &gt; .99e30:
        c_p[0] = 0
        ypp[0] = 0
    else:
        c_p[0] = 0.5
        ypp[0] = 3 * ( new_dj - start_deriv ) / cj

    # forward substitution portion
    j = 1
    while j &lt; (n-1):
        # shuffle new values to old
        old_x = new_x
        old_y = new_y
        aj = cj
        old_dj = new_dj
        # generate new quantities
        new_x = knots[j+1]
        new_y = values[j+1]
        cj = new_x - old_x
        new_dj = ( new_y - old_y ) / cj
        bj = 2*(cj + aj)
        inv_denom = 1. / ( bj - aj * c_p[j-1])
        dj = 6*(new_dj - old_dj)
        ypp[j] = (dj - aj * ypp[j-1]) * inv_denom
        c_p[j] = cj * inv_denom
        j += 1

    # handle the end derivative
    if end_deriv &gt; .99e30 :
        c_p[j] = 0
        ypp[j] = 0
    else :
        old_x = new_x
        old_y = new_y
        aj = cj
        old_dj = new_dj
        cj = 0 # this has the same effect as skipping c_n
        new_dj = end_deriv
        bj = 2*(cj + aj)
        inv_denom = 1. / (bj - aj * c_p[j-1])
        dj = 6*(new_dj - old_dj)
        ypp[j] = (dj - aj * ypp [j-1]) * inv_denom
        c_p[j] = cj * inv_denom

    # as we &#39;re storing d_j in y &#39;&#39;_j , y &#39;&#39;_n = d_n is a no-op
    # backward substitution portion
    while j &gt; 0:
        j -= 1
        ypp[j] = ypp[j] - c_p[j]* ypp[j+1]

    return ypp</code></pre>
</details>
</dd>
<dt id="pycelp.util.newint"><code class="name flex">
<span>def <span class="ident">newint</span></span>(<span>x, a, b, u, v, up, vp)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapted from <a href="https://arxiv.org/pdf/2001.09253.pdf">https://arxiv.org/pdf/2001.09253.pdf</a>
Originally Released under a CC0 license by Haysn Hornbeck</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def newint(x,a,b,u,v,up,vp):
    &#34;&#34;&#34;
    Adapted from https://arxiv.org/pdf/2001.09253.pdf
    Originally Released under a CC0 license by Haysn Hornbeck
    &#34;&#34;&#34;
    if b &lt; a:
        print(&#39;Warning: b must be &gt; a&#39;)
    ba = ( b - a )
    xa = ( x - a )
    inv_ba = 1. / ba
    bx = ( b - x )
    ba2 = ba * ba
    lower = xa * v + bx * u
    C = ( xa * xa - ba2 ) * xa * vp
    D = ( bx * bx - ba2 ) * bx * up
    return ( lower + (.16666666666666666666) *( C + D ) ) * inv_ba</code></pre>
</details>
</dd>
<dt id="pycelp.util.rad_field_bframe"><code class="name flex">
<span>def <span class="ident">rad_field_bframe</span></span>(<span>wlang, thetab, rphot, include_limbdark=True, photo_temp=6000.0)</span>
</code></dt>
<dd>
<div class="desc"><p>inputs:
wlang - wavelength of transition in angstrom
thetab - inclination of the magnetic field wrt solar vertical in radians
rphot - height above surface in radius units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def rad_field_bframe(wlang,thetab,rphot,include_limbdark = True,photo_temp = 6000.):
    &#34;&#34;&#34;
    inputs:
      wlang - wavelength of transition in angstrom
      thetab - inclination of the magnetic field wrt solar vertical in radians
      rphot - height above surface in radius units
    &#34;&#34;&#34;

    nline = len(wlang)
    amu_b = np.cos(thetab)
    factor = (0.5)*(3.0*amu_b*amu_b-1.0)

    ## LANDI DEGL&#39;INNOCENTI &amp; LANDOLFI (2004) Equation 12.32
    sg = 1.0 / (1.0 + rphot)   ## sin(gamma)
    cg2 = 1.-sg**2
    cg  = np.sqrt(cg2)
    cg3 = cg2*cg
    logval = (np.log1p(sg) - np.log(cg))  ## old: np.log((1.+sg)/cg)
    b0 = (1.-cg3)/3.
    b1 = (8.*cg3 - 3.*cg2 - 2.) / 24. - cg**4 / (8.*sg) * logval
    b2 = (cg-1.)*(3.*cg3 + 6.*cg2 + 4.*cg + 2.) / (15.*(cg+1.))
    a0 = 1. - cg
    a1 = cg - 0.5 - 0.5*cg2/sg*logval
    a2 = (cg+2.)*(cg-1.) / (3.*(cg+1.))

    cc = 2.99792458e10
    hh = 6.626176e-27
    bk = 1.380662e-16

    nu = 1.e8 * (cc/wlang)
    boltzm1 = np.expm1(hh*nu/(bk*photo_temp))
    planck = 2.0*hh*(nu**3)/(cc*cc*boltzm1)

    ## NEED TO IMPLEMENT LIMB DARK FLAG HERE
    uc = np.interp(wlang,lambdaCLV,uCLV)
    vc = np.interp(wlang,lambdaCLV,vCLV)
    if not include_limbdark:
        uc = 0.*uc
        vc = 0.*vc

    Jnu = 0.5 * planck * (a0 + a1*uc + a2*vc)
    Knu = 0.5 * planck * (b0 + b1*uc + b2*vc)

    radj = np.zeros((3,nline))
    radj[0,:] = Jnu
    radj[2,:] = (3.0*Knu-Jnu)/(2.0*(2**0.5)) * factor

    return radj</code></pre>
</details>
</dd>
<dt id="pycelp.util.seeSolve"><code class="name flex">
<span>def <span class="ident">seeSolve</span></span>(<span>aa, weight, see_lev, see_k)</span>
</code></dt>
<dd>
<div class="desc"><p>Solves the statistical equilibrium equations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def seeSolve(aa,weight,see_lev,see_k):
    &#34;&#34;&#34;
    Solves the statistical equilibrium equations
    &#34;&#34;&#34;

    ## particle conservation equation
    aa[0,:] = weight
    bb = np.zeros(weight.shape[0])
    bb[0] = 1.

    ## solve system
    xx = np.linalg.solve(aa,bb)

    ## check solution
    wk0 = (weight != 0)
    ntot = np.sum(weight[wk0]*xx[wk0])
    if (abs(1-ntot) &gt; 1.e-8):
        print(&#39;Warning:  Solution may not be accurate&#39;)

    ## reshape into rho matrix
    rho = np.zeros((max(see_lev)+1,max(see_k)+1))
    for i in range(weight.shape[0]):
        rho[see_lev[i],see_k[i]] = xx[i]

    return rho</code></pre>
</details>
</dd>
<dt id="pycelp.util.setupSEE"><code class="name flex">
<span>def <span class="ident">setupSEE</span></span>(<span>qnj, all_ks=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setupSEE(qnj,all_ks=False):

    ## Determine the indices of the statistical equilibrium matrix elements
    ## - No-coherence hypothesis is assumed, thus Q = 0 throughout
    ## - LD&amp;L (2004) Section 13.5 discusses that K can be limited to even values.
    ##   Below, the option to use all k values remains, but it is likely not
    ##   necessary unless the code is extended to other use cases.
    ## - The total number of equations is given for the Q=0,K=even case from
    ##   the equations in Section 13.5.  For all K, each level contributes
    ##   2*J + 1 equations for each of its K values

    if all_ks:
        see_dk  = 1
        see_neq = int(np.sum(2*qnj+1))
    else:
        see_dk = 2
        if (qnj[0]%1 == 0.0):
            see_neq   = int(np.sum(qnj+1))
        else:
            see_neq   = int(np.sum(qnj+0.5))

    see_index = np.arange(see_neq)             ## index of the SEE table element
    see_lev   = np.zeros(see_neq,dtype = int)  ## energy level index
    see_k     = np.zeros(see_neq,dtype = int)  ## value of k

    nlev = len(qnj)

    i = 0
    for lev in range(nlev):
        for k in range(0,int(2*qnj[lev]+1),see_dk):
            see_lev[i] = lev
            see_k[i] = k
            i += 1

    return see_neq,see_index,see_lev,see_k,see_dk</code></pre>
</details>
</dd>
<dt id="pycelp.util.spintarr"><code class="name flex">
<span>def <span class="ident">spintarr</span></span>(<span>xnew, knots, values, ydiv2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def spintarr(xnew,knots,values,ydiv2):
    ynew = np.zeros_like(xnew)
    i = 0
    for n,x in enumerate(xnew):
        while (i+1 &lt; len(knots)) and (knots[i+1] &lt; x) :
            i += 1
        ynew[n] =  newint(x,knots[i],knots[i+1],values[i],values[i+1],ydiv2[i],ydiv2[i+1])
    return ynew</code></pre>
</details>
</dd>
<dt id="pycelp.util.spintone"><code class="name flex">
<span>def <span class="ident">spintone</span></span>(<span>xnew, knots, values, ydiv2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def spintone(xnew,knots,values,ydiv2):
    i = 0
    while (i+1 &lt; len(knots)) and (knots[i+1] &lt; xnew):
        i += 1
    ynew =  newint(xnew,knots[i],knots[i+1],values[i],values[i+1],ydiv2[i],ydiv2[i+1])
    return ynew</code></pre>
</details>
</dd>
<dt id="pycelp.util.vac2air"><code class="name flex">
<span>def <span class="ident">vac2air</span></span>(<span>wvlamb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vac2air(wvlamb):
    ww = (wvlamb &lt; 2000.)
    convl = np.zeros_like(wvlamb)
    convl[ww] = wvlamb[ww]
    ww = (wvlamb &gt;= 2000.)
    convl[ww] =  wvlamb[ww]/(1. + 2.735182e-4 + 131.4182/(wvlamb[ww]**2) + 2.76249e8/(wvlamb[ww]**4))
    return convl</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycelp" href="index.html">pycelp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pycelp.util.calcLande" href="#pycelp.util.calcLande">calcLande</a></code></li>
<li><code><a title="pycelp.util.getDcoeff" href="#pycelp.util.getDcoeff">getDcoeff</a></code></li>
<li><code><a title="pycelp.util.getEcoeff" href="#pycelp.util.getEcoeff">getEcoeff</a></code></li>
<li><code><a title="pycelp.util.get_eTransType" href="#pycelp.util.get_eTransType">get_eTransType</a></code></li>
<li><code><a title="pycelp.util.new_second_derivative" href="#pycelp.util.new_second_derivative">new_second_derivative</a></code></li>
<li><code><a title="pycelp.util.newint" href="#pycelp.util.newint">newint</a></code></li>
<li><code><a title="pycelp.util.rad_field_bframe" href="#pycelp.util.rad_field_bframe">rad_field_bframe</a></code></li>
<li><code><a title="pycelp.util.seeSolve" href="#pycelp.util.seeSolve">seeSolve</a></code></li>
<li><code><a title="pycelp.util.setupSEE" href="#pycelp.util.setupSEE">setupSEE</a></code></li>
<li><code><a title="pycelp.util.spintarr" href="#pycelp.util.spintarr">spintarr</a></code></li>
<li><code><a title="pycelp.util.spintone" href="#pycelp.util.spintone">spintone</a></code></li>
<li><code><a title="pycelp.util.vac2air" href="#pycelp.util.vac2air">vac2air</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>